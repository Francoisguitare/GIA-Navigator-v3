
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GIA Navigator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
      body {
        font-family: 'Inter', sans-serif;
      }
      .input-grid-cell.cell-active {
        box-shadow: 0 0 0 3px #3B82F6;
        border-color: #3B82F6;
      }
      .note-dot {
        transition: all 0.2s;
        stroke-width: 2;
      }
      @keyframes pulse-note {
        0% { r: 9; opacity: 1; }
        50% { r: 11; opacity: 0.8; }
        100% { r: 9; opacity: 1; }
      }
      .note-dot-active {
        animation: pulse-note 1s infinite;
      }
      .note-dot-text {
        font-size: 10px;
        font-weight: bold;
        fill: #111827; /* gray-900 */
        pointer-events: none;
        text-anchor: middle;
        dominant-baseline: central;
      }
      .note-name-text {
        font-size: 8px;
        font-weight: 500;
        fill: #f3f4f6; /* gray-100 */
        pointer-events: none;
        text-anchor: middle;
      }
      .fret-number-text {
        font-size: 10px;
        font-weight: bold;
        fill: #9ca3af; /* gray-400 */
        text-anchor: middle;
      }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 p-2 sm:p-4">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>

    <script type="text/babel">
    
// ====================================================================================
// START: constants.js
// ====================================================================================

const NOTES = {
    sharp: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
    flat:  ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B']
};
const MAJOR_SCALE_INTERVALS = [0, 2, 4, 5, 7, 9, 11];
const MINOR_PENTATONIC_INTERVALS = [0, 3, 5, 7, 10];
const MAJOR_PENTATONIC_INTERVALS = [0, 2, 4, 7, 9];
const TOTAL_CELLS = 24;
const TUNING = ['E', 'A', 'D', 'G', 'B', 'E'];
const PRESET_PROGRESSIONS = [
    { name: "Pop/Rock Mineur", chords: ['Am', '', 'G', '', 'D', '', 'E', ''] },
    { name: "Jazz ii-V-I (Majeur)", chords: ['Dm7', '', 'G7', '', 'Cmaj7', ''] },
    { name: "Pop/Rock Majeur", chords: ['C', '', 'G', '', 'Am', '', 'F', ''] },
    { name: "Blues 12 Mesures (en A)", chords: ['A7','','A7','','A7','','A7','','D7','','D7','','A7','','A7','','E7','','D7','','A7','','A7',''] }
];
const PlaybackState = {
    Stopped: 'Stopped',
    Countdown: 'Countdown',
    Playing: 'Playing',
};

// ====================================================================================
// START: services/musicTheory.js
// ====================================================================================

class NotePositions {
    positions = {};
    constructor() { this.calculateNotePositions(); }
    calculateNotePositions() {
        NOTES.sharp.forEach(note => this.positions[note] = []);
        NOTES.flat.forEach(note => this.positions[note] = []);
        for (let stringIndex = 0; stringIndex < 6; stringIndex++) {
            const openStringNote = TUNING[5 - stringIndex];
            let currentNoteIndex = getNoteInfo(openStringNote).index;
            for (let fret = 0; fret <= 17; fret++) {
                const noteNameSharp = NOTES.sharp[currentNoteIndex % 12];
                const noteNameFlat = NOTES.flat[currentNoteIndex % 12];
                if (!this.positions[noteNameSharp]) this.positions[noteNameSharp] = [];
                this.positions[noteNameSharp].push([stringIndex, fret]);
                if (noteNameSharp !== noteNameFlat) {
                     if (!this.positions[noteNameFlat]) this.positions[noteNameFlat] = [];
                     this.positions[noteNameFlat].push([stringIndex, fret]);
                }
                currentNoteIndex++;
            }
        }
    }
    get(note) { return this.positions[note] || []; }
}

function getNoteInfo(noteName) {
    if (!noteName || typeof noteName !== 'string') return { root: '?', index: -1 };
    const match = noteName.match(/^([A-G])([#b]?)/);
    if (!match) return { root: '?', index: -1 };
    const root = match[0];
    const sharpIndex = NOTES.sharp.indexOf(root);
    const flatIndex = NOTES.flat.indexOf(root);
    if (sharpIndex !== -1) return { root, index: sharpIndex };
    if (flatIndex !== -1) return { root, index: flatIndex };
    const map = { 'A#': 'Bb', 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab' };
    const equivalentFlat = map[root] || root;
    const index = NOTES.flat.indexOf(equivalentFlat);
    return { root, index };
}

function getChordQuality(chordName) {
    if (!chordName) return '';
    if (chordName.includes('maj7') || chordName.includes('M7') || chordName.includes('Œî')) return 'major7';
    if (chordName.includes('m7') || chordName.includes('min7')) return 'minor7';
    if (chordName.includes('¬∞7') || chordName.includes('dim7')) return 'diminished7';
    if (chordName.includes('dim') || chordName.includes('¬∞')) return 'diminished';
    if (chordName.includes('m') && !chordName.includes('maj')) return 'minor';
    if (chordName.includes('7')) return 'dominant7';
    return 'major';
}

function getIntervalNote(rootNote, semitones, key) {
    const rootInfo = getNoteInfo(rootNote);
    if (rootInfo.index === -1) return '?';
    const noteArray = key.keySignatureType === 'flat' ? NOTES.flat : NOTES.sharp;
    const targetIndex = (rootInfo.index + semitones) % 12;
    return noteArray[targetIndex];
}

function findDegree(chordName, key) {
    const chordRootInfo = getNoteInfo(chordName);
    if (chordRootInfo.index === -1) return '?';
    const keyRootIndex = getNoteInfo(key.root).index;
    if (keyRootIndex === -1) return '?';
    const quality = getChordQuality(chordName);
    const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];
    const interval = (chordRootInfo.index - keyRootIndex + 12) % 12;
    let degree = '?'; let alteration = '';
    const referenceIntervals = MAJOR_SCALE_INTERVALS;
    for (let i = 0; i < referenceIntervals.length; i++) {
        const scaleInterval = referenceIntervals[i];
        if (interval === scaleInterval) { degree = romanNumerals[i]; break; }
        if (interval === scaleInterval - 1) { alteration = 'b'; degree = romanNumerals[i]; break; }
        if (i > 0 && interval === referenceIntervals[i-1] + 1) { 
            if(interval === 3) continue; 
            alteration = '#'; degree = romanNumerals[i-1]; break; 
        }
    }
    if (degree === '?') {
         if (interval === 6) { alteration = '#'; degree = 'IV'; }
         else { return '?'; }
    }
    if (quality.includes('minor')) { degree = degree.toLowerCase(); }
    else if (quality.includes('diminished')) { degree = degree.toLowerCase() + '¬∞'; }
    return alteration + degree;
}

function getScaleNotes(key) {
    const noteArray = key.keySignatureType === 'flat' ? NOTES.flat : NOTES.sharp;
    const intervals = key.type === 'major' ? MAJOR_SCALE_INTERVALS : [0, 2, 3, 5, 7, 8, 10];
    const rootIndex = getNoteInfo(key.root).index;
    if (rootIndex === -1) return [];
    return intervals.map(i => noteArray[(rootIndex + i) % 12]);
}

function getPentatonicScaleNotes(key, notePositions) {
    const noteArray = key.keySignatureType === 'flat' ? NOTES.flat : NOTES.sharp;
    const intervals = key.type === 'major' ? MAJOR_PENTATONIC_INTERVALS : MINOR_PENTATONIC_INTERVALS;
    const rootIndex = getNoteInfo(key.root).index;
    if (rootIndex === -1) return [];
    return intervals.map(i => noteArray[(rootIndex + i) % 12]);
}

function getChordTones(chordName, key) {
    const noteInfo = getNoteInfo(chordName);
    const quality = getChordQuality(chordName);
    if(noteInfo.index === -1) return [];
    const root = noteInfo.root;
    const thirdInterval = quality.includes('minor') || quality.includes('diminished') ? 3 : 4;
    const fifthInterval = quality.includes('diminished') ? 6 : 7;
    const third = getIntervalNote(root, thirdInterval, key);
    const fifth = getIntervalNote(root, fifthInterval, key);
    let tones = [root, third, fifth];
    if (quality.includes('7')) {
        let seventhInterval;
        if(quality === 'major7') seventhInterval = 11;
        else if (quality === 'diminished7') seventhInterval = 9;
        else seventhInterval = 10;
        tones.push(getIntervalNote(root, seventhInterval, key));
    }
    return tones;
}

function checkIfOutOfKey(chordName, key, degree) {
    const scaleNotes = getScaleNotes(key);
    if (!scaleNotes.length) return false;
    const scaleNotesIndices = scaleNotes.map(n => getNoteInfo(n).index);
    const chordTonesNotes = getChordTones(chordName, key);
    for (const tone of chordTonesNotes) {
        const toneIndex = getNoteInfo(tone).index;
        if (!scaleNotesIndices.includes(toneIndex)) {
            if (key.type === 'minor' && degree.toUpperCase().replace(/[#b]/g, '') === 'V') {
                 const harmonicMinorLeadingToneIndex = (getNoteInfo(key.root).index + 11) % 12;
                 if (toneIndex === harmonicMinorLeadingToneIndex) continue;
            }
            return true;
        }
    }
    return false;
}

function getExpressivePalette(front, rootNote, key) {
    let palette = [];
    if (front === 'R√âSOLUTION') {
        palette = [
            { note: getIntervalNote(rootNote, 2, key), interval: '9e', intention: 'Lyrisme / Douceur', description: '√âmotion : Doux, apaisant. Action : Id√©al pour les phrases longues et m√©lodiques.' },
            { note: getIntervalNote(rootNote, 9, key), interval: '6M', intention: 'Funk / Optimisme', description: 'Couleur : √âclaircit le son mineur (Dorian). Action : Pour les plans rythm√©s et dansants.' },
            { note: getIntervalNote(rootNote, 6, key), interval: '#11', intention: 'R√™veur / Flottant', description: 'Effet : Sensation a√©rienne et myst√©rieuse (Lydien). Action : √Ä utiliser sur des plans qui montent ou glissent.' }
        ];
    } else {
         palette = [
            { note: getIntervalNote(rootNote, 1, key), interval: 'b9', intention: 'Tension Ultime', description: '√âmotion : Choc et urgence. Action : √Ä r√©server au Climax. Force la r√©solution.' },
            { note: getIntervalNote(rootNote, 3, key), interval: '#9', intention: 'Action / Hard Rock', description: 'Couleur : Puissante et agressive (Blues/Rock). Action : Pour les plans rythmiques rapides et percussifs.' },
            { note: getIntervalNote(rootNote, 2, key), interval: '9M', intention: 'Couleur Solide / Stable', description: 'HYPERSTRUCTURE SOLIDE. Moins agressif que le Tritone. Donne un son riche et clair.' }
        ];
    }
    return palette.map(p => ({ ...p, type: 'expressive' }));
}

function analyzeSingleChord(chordName, key, nextChordName) {
    const noteInfo = getNoteInfo(chordName);
    const quality = getChordQuality(chordName);
    const degree = findDegree(chordName, key);
    const isOutOfKey = checkIfOutOfKey(chordName, key, degree);
    const isPotentiallyDominant = (degree.replace(/[#b]/g, '').toUpperCase() === 'V');
    let isConfirmedDominant = false;
    if (isPotentiallyDominant) {
        const currentRootIndex = getNoteInfo(chordName).index;
        const nextRootIndex = getNoteInfo(nextChordName).index;
        if (currentRootIndex !== -1 && nextRootIndex !== -1 && (currentRootIndex - nextRootIndex + 12) % 12 === 7) {
            isConfirmedDominant = true;
        }
    }
    let front;
    if (isConfirmedDominant) { front = 'TENSION'; }
    else if (isOutOfKey) { front = 'OUT_OF_KEY'; }
    else { front = 'R√âSOLUTION'; }
    const actionRythmique = front === 'TENSION' || front === 'OUT_OF_KEY' ? 'RAPIDE / AGRESSIF' : 'LENT / LYRIQUE';
    let structuralNotes = [];
    structuralNotes.push({ note: noteInfo.root, interval: 'R', type: 'fondatrice', intention: 'Stabilit√©' });
    if (front === 'TENSION') {
        structuralNotes.push({ note: getIntervalNote(noteInfo.root, 4, key), interval: '3M', type:'fondatrice', intention: 'Couleur' });
        structuralNotes.push({ note: getIntervalNote(noteInfo.root, 10, key), interval: 'b7', type:'fondatrice', intention: 'Tension' });
    } else {
        structuralNotes.push({
            note: getIntervalNote(noteInfo.root, quality.includes('minor') ? 3 : 4, key),
            interval: quality.includes('minor') ? '3m' : '3M',
            type: 'fondatrice',
            intention: 'Couleur'
        });
    }
    const expressivePalette = getExpressivePalette(front, noteInfo.root, key);
    const allTargetOptions = [...structuralNotes, ...expressivePalette];
    return { accord: chordName, degre: degree, front, actionRythmique, allTargetOptions };
}

function detectKey(firstChord) {
    const { root } = getNoteInfo(firstChord);
    const quality = getChordQuality(firstChord);
    const flatKeys = ['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb'];
    const flatMinorKeys = ['Dm', 'Gm', 'Cm', 'Fm', 'Bbm', 'Ebm']; 
    let keySignatureType = 'sharp';
    if (flatKeys.includes(root) || flatMinorKeys.includes(root+'m') || root.includes('b')) {
        keySignatureType = 'flat';
    }
    if (quality.includes('minor')) {
        return { name: `${root} mineur`, root: root, type: 'minor', keySignatureType };
    }
    return { name: `${root} Majeur`, root: root, type: 'major', keySignatureType };
}

function analyzeProgression(chords, notePositions) {
    const firstChord = chords.find(c => c.trim());
    if (!firstChord) {
        return { key: null, results: [] };
    }
    const key = detectKey(firstChord);
    const results = [];
    const activeChordsWithIndices = chords
        .map((chord, index) => ({ chord: chord.trim(), index }))
        .filter(item => item.chord !== '');
    if (activeChordsWithIndices.length > 0) {
        activeChordsWithIndices.forEach((chordItem, activeIndex) => {
            const nextChordItem = activeChordsWithIndices[activeIndex + 1] || activeChordsWithIndices[0];
            const analysis = analyzeSingleChord(chordItem.chord, key, nextChordItem.chord);
            const fundamentalNote = analysis.allTargetOptions.find(opt => opt.interval === 'R');
            results.push({
                ...analysis,
                gridIndex: chordItem.index,
                analysisIndex: activeIndex,
                selectedNote: fundamentalNote
            });
        });
    }
    return { key, results };
}

// ====================================================================================
// START: services/toneService.js
// ====================================================================================

class ToneService {
    bassSynth; chordSynth; metronome;
    part = null; countdownPart = null;
    currentLoopEndMeasures = 0;
    setActiveGridIndex; setPlaybackState; updateNeckCallback;
    constructor(setActiveGridIndex, setPlaybackState, updateNeckCallback) {
        this.setActiveGridIndex = setActiveGridIndex;
        this.setPlaybackState = setPlaybackState;
        this.updateNeckCallback = updateNeckCallback;
    }
    async init() {
        this.bassSynth = new Tone.MonoSynth({
            oscillator: { type: 'fatsawtooth' },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 },
            filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.8, baseFrequency: 200, octaves: 4 }
        }).toDestination();
        this.chordSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "fatsawtooth", count: 3, spread: 30 },
            envelope: { attack: 0.05, decay: 0.1, sustain: 0.7, release: 0.8 }
        }).toDestination();
        this.metronome = new Tone.MembraneSynth({
            pitchDecay: 0.01,
            octaves: 10,
            oscillator: { type: 'square' },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 }
        }).toDestination();
    }
    setTempo(bpm) { Tone.Transport.bpm.value = bpm; }
    setVolume(instrument, value) {
        if (!this.bassSynth) return;
        switch (instrument) {
            case 'bass': this.bassSynth.volume.value = value; break;
            case 'chord': this.chordSynth.volume.value = value; break;
            case 'metro': this.metronome.volume.value = value; break;
        }
    }
    updateSchedule(chords, analysisResults, notePositions) {
        if (this.part) this.part.dispose();
        const lastChordIndex = chords.map(c => c.trim()).lastIndexOf(chords.filter(c => c.trim()).pop() || '');
        if (lastChordIndex === -1) { this.currentLoopEndMeasures = 0; return; }
        const totalBeatsInProgression = (lastChordIndex + 1) * 2;
        const loopEndMeasures = Math.ceil(totalBeatsInProgression / 4);
        this.currentLoopEndMeasures = loopEndMeasures;
        const totalLoopBeats = loopEndMeasures * 4;
        const events = [];
        for (let i = 0; i <= lastChordIndex; i++) {
            const chordName = chords[i];
            if (chordName) {
                const beat = i * 2;
                const time = `${Math.floor(beat / 4)}:${beat % 4}:0`;
                const { root: rootNote } = getNoteInfo(chordName);
                if (rootNote !== '?') {
                    let nextChangeIndex = -1;
                    for (let j = i + 1; j <= lastChordIndex; j++) { if (chords[j]) { nextChangeIndex = j; break; } }
                    const endTimeBeats = (nextChangeIndex !== -1) ? nextChangeIndex * 2 : totalLoopBeats;
                    const durationBeats = endTimeBeats - beat;
                    if (durationBeats > 0) {
                        const durationNotation = `${Math.floor(durationBeats / 4)}:${durationBeats % 4}:0`;
                        events.push({ time, note: rootNote + '2', duration: durationNotation, type: 'bass' });
                        const analysis = analysisResults.find(r => r.gridIndex === i);
                        if(analysis) {
                            const chordTones = analysis.allTargetOptions.filter(o => o.type === 'fondatrice' && o.interval !== 'b7').map(n => n.note + '4');
                             if (chordTones.length > 0) {
                                events.push({ time, notes: chordTones, duration: durationNotation, type: 'chord' });
                            }
                        }
                    }
                }
            }
        }
        const loopEndCells = this.currentLoopEndMeasures * 2;
        for (let i = 0; i < loopEndCells; i++) {
            const beat = i * 2;
            const time = `${Math.floor(beat / 4)}:${beat % 4}:0`;
            events.push({ time, gridIndex: i, type: 'highlight' });
        }
        for (let beat = 0; beat < totalLoopBeats; beat++) {
            const time = `${Math.floor(beat / 4)}:${beat % 4}:0`;
            events.push({ time, note: beat % 4 === 0 ? 'C5' : 'C4', type: 'metro' });
        }
        events.sort((a, b) => Tone.Time(a.time).toSeconds() - Tone.Time(b.time).toSeconds());
        if (events.length > 0 && loopEndMeasures > 0) {
            this.part = new Tone.Part((time, value) => {
                if (value.type === 'bass') { this.bassSynth.triggerAttackRelease(value.note, value.duration, time); }
                else if (value.type === 'chord') { this.chordSynth.triggerAttackRelease(value.notes, value.duration, time); }
                else if (value.type === 'metro') { this.metronome.triggerAttackRelease(value.note, '16n', time); }
                else if (value.type === 'highlight') {
                    Tone.Draw.schedule(() => {
                        this.setActiveGridIndex(value.gridIndex);
                        this.updateNeckCallback(value.gridIndex);
                    }, time);
                }
            }, events).start("1m");
            this.part.loop = true;
            this.part.loopEnd = `${loopEndMeasures}m`;
        }
    }
    play(chords, analysisResults, notePositions) {
        this.updateSchedule(chords, analysisResults, notePositions);
        if (this.currentLoopEndMeasures === 0) return;
        this.setPlaybackState(PlaybackState.Countdown);
        const countdownEvents = [{ time: '0:0', count: 4 }, { time: '0:1', count: 3 }, { time: '0:2', count: 2 }, { time: '0:3', count: 1 }];
        if (this.countdownPart) this.countdownPart.dispose();
        this.countdownPart = new Tone.Part((time, value) => { this.metronome.triggerAttackRelease('C5', '8n', time); }, countdownEvents).start(0);
        this.countdownPart.loop = false;
        Tone.Transport.scheduleOnce(() => { this.setPlaybackState(PlaybackState.Playing); }, '1m'); 
        Tone.Transport.loop = true;
        Tone.Transport.loopStart = '1m';
        Tone.Transport.loopEnd = `${this.currentLoopEndMeasures + 1}m`;
        Tone.Transport.start();
    }
    stop() {
        if (this.countdownPart) { this.countdownPart.stop(0); this.countdownPart.dispose(); this.countdownPart = null; }
        if (this.part) { this.part.stop(0); this.part.dispose(); this.part = null; }
        if(this.bassSynth) { this.bassSynth.triggerRelease(); this.chordSynth.releaseAll(); }
        Tone.Transport.stop();
        Tone.Transport.cancel(0);
        Tone.Transport.position = 0;
        Tone.Transport.loop = false;
        Tone.Transport.loopStart = 0;
        this.setPlaybackState(PlaybackState.Stopped);
        this.setActiveGridIndex(-1);
    }
}

// ====================================================================================
// START: components/Icons.js
// ====================================================================================

const FullscreenEnterIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 8V4m0 0h4M4 4l5 5m11-5h-4m0 0v4m0-4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5h-4m0 0v-4m0 4l-5-5" />
    </svg>
);
const FullscreenExitIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 4h5v5M9 4H4v5M15 20h5v-5M9 20H4v-5" />
    </svg>
);
const PlayIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
);
const SmallPlayIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8.002v3.996a1 1 0 001.555.832l3.197-1.998a1 1 0 000-1.664l-3.197-1.998z" clipRule="evenodd" />
    </svg>
);
const StopIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
);
const MetronomeIcon = () => (
    <svg title="M√©tronome" xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
        <path strokeLinecap="round" strokeLinejoin="round" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
    </svg>
);
const BassIcon = () => (
    <svg title="Basse" xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2z" />
    </svg>
);
const ChordIcon = () => (
    <svg title="Nappes" xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 17v-2m3 2v-4m3 4v-6m3 6V7m-9 4h9" />
    </svg>
);
const LevelIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
        <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
    </svg>
);
const TimeIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.414-1.415L11 9.586V6z" clipRule="evenodd" />
    </svg>
);
const YouTubeIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-red-500" viewBox="0 0 24 24" fill="currentColor">
        <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z" />
    </svg>
);
const ExternalLinkIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
    </svg>
);
const XIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={3}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
    </svg>
);
const EyeOffIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a9.97 9.97 0 01-1.563 3.029m0 0l-2.175 2.175m0 0l-3.29 3.29" />
    </svg>
);

// ====================================================================================
// START: components/* (Header, GamificationHeader, etc.)
// ====================================================================================

const Header = () => {
    const [isFullscreen, setIsFullscreen] = React.useState(false);
    const toggleFullScreen = () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.warn(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        } else {
            if (document.exitFullscreen) document.exitFullscreen();
        }
    };
    React.useEffect(() => {
        const onFullscreenChange = () => setIsFullscreen(!!document.fullscreenElement);
        document.addEventListener('fullscreenchange', onFullscreenChange);
        return () => document.removeEventListener('fullscreenchange', onFullscreenChange);
    }, []);
    return (
        <React.Fragment>
            <div className="absolute top-2 right-2 z-20">
                <button onClick={toggleFullScreen} title="Plein √©cran" className="p-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition">
                    {isFullscreen ? <FullscreenExitIcon /> : <FullscreenEnterIcon />}
                </button>
            </div>
            <header className="text-center mb-2">
                <h1 className="text-3xl md:text-4xl font-extrabold text-white mb-1">üé∏ GIA Navigator</h1>
                <p className="text-md text-gray-400">Votre plan d'action visuel pour l'improvisation.</p>
            </header>
        </React.Fragment>
    );
};

const ProgressBar = ({ value, max, colorClass }) => (
    <div className="w-full bg-gray-700 rounded-full h-2.5">
        <div 
            className={`${colorClass} h-2.5 rounded-full transition-all duration-500`} 
            style={{ width: `${Math.min(100, (value / max) * 100)}%` }}
        ></div>
    </div>
);
const GamificationHeader = ({ level, xp, xpForNextLevel, practiceTime, practiceTimeGoal }) => {
    const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
        const secs = (seconds % 60).toString().padStart(2, '0');
        return `${mins}:${secs}`;
    };
    return (
        <div className="mb-2 p-3 bg-gray-800/50 rounded-xl border border-gray-700 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="flex items-center gap-3">
                <LevelIcon />
                <div className="w-full">
                    <div className="flex justify-between items-center mb-1 text-sm">
                        <span className="font-bold text-white">Niveau {level}</span>
                        <span className="font-semibold text-gray-400">{xp} / {xpForNextLevel} XP</span>
                    </div>
                    <ProgressBar value={xp} max={xpForNextLevel} colorClass="bg-violet-500" />
                </div>
            </div>
            <div className="flex items-center gap-3">
                <TimeIcon />
                <div className="w-full">
                     <div className="flex justify-between items-center mb-1 text-sm">
                        <span className="font-bold text-white">Temps de pratique</span>
                        <span className="font-semibold text-gray-400">{formatTime(practiceTime)}</span>
                    </div>
                    <ProgressBar value={practiceTime} max={practiceTimeGoal} colorClass="bg-green-500" />
                </div>
            </div>
        </div>
    );
};

const YouTubeBackingTrack = ({ activeTrack, savedTracks, onSaveTrack, onSelectTrack, onDeleteTrack }) => {
    const [inputValue, setInputValue] = React.useState('');
    const [isLoading, setIsLoading] = React.useState(false);
    const [isPlayerVisible, setIsPlayerVisible] = React.useState(false);
    const getYoutubeVideoId = (url) => {
        if (!url) return null;
        const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
        const match = url.match(regExp);
        return (match && match[2].length === 11) ? match[2] : null;
    };
    const handleSave = async () => {
        const trimmedUrl = inputValue.trim();
        const videoId = getYoutubeVideoId(trimmedUrl);
        if (!videoId) { alert("Veuillez entrer une URL YouTube valide."); return; }
        setIsLoading(true);
        try {
            const response = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`);
            if (!response.ok) throw new Error('Could not fetch video metadata.');
            const data = await response.json();
            onSaveTrack({ id: videoId, url: trimmedUrl, title: data.title || `Vid√©o ${videoId}` });
            setInputValue('');
        } catch (error) {
            console.error("Error fetching YouTube title:", error);
            onSaveTrack({ id: videoId, url: trimmedUrl, title: `Vid√©o ${videoId}` });
            setInputValue('');
        } finally { setIsLoading(false); }
    };
    const handleSelectTrack = (track) => {
        onSelectTrack(track);
        setIsPlayerVisible(false);
    };
    return (
        <div className="pt-2 pb-3 border-y border-gray-700/50 mb-3">
            <div className="flex justify-between items-center mb-2 gap-2 flex-wrap">
                 <h3 className="text-sm font-bold text-gray-300 flex items-center gap-2">
                    <YouTubeIcon />
                    <span>Backing Track Actif: </span>
                    {activeTrack ? <span className="text-red-400 font-normal truncate max-w-[200px] sm:max-w-xs" title={activeTrack.title}>{activeTrack.title}</span> : <span className="text-gray-500 font-normal">Aucun</span>}
                </h3>
                {activeTrack && !isPlayerVisible && (
                     <button onClick={() => setIsPlayerVisible(true)} className="flex items-center justify-center gap-2 text-sm bg-gray-700 hover:bg-gray-600 text-gray-300 font-semibold py-2 px-3 rounded-lg transition" title="Lancer le lecteur">
                        <SmallPlayIcon /> <span>Lancer le Backing Track</span>
                    </button>
                )}
            </div>
            <div className="flex flex-col sm:flex-row gap-2 mt-3">
                <input type="text" value={inputValue} onChange={(e) => setInputValue(e.target.value)} placeholder="Collez une URL YouTube ici pour l'ajouter √† vos favoris..." className="flex-grow bg-gray-900 border border-gray-600 rounded-lg w-full p-2 text-sm text-white transition focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500/50" />
                <button onClick={handleSave} disabled={isLoading} className="w-full sm:w-auto text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 font-semibold py-2 px-4 rounded-lg transition disabled:bg-gray-800 disabled:cursor-not-allowed">
                    {isLoading ? 'Analyse...' : 'Sauvegarder'}
                </button>
            </div>
            {savedTracks.length > 0 && (
                <div className="mt-4">
                    <h4 className="text-xs font-bold text-gray-400 tracking-wider uppercase mb-2">Mes Backing Tracks</h4>
                    <div className="flex flex-wrap gap-2">
                        {savedTracks.map(track => (
                            <div key={track.id} className="relative group">
                                <button onClick={() => handleSelectTrack(track)} className={`pr-7 pl-3 py-1 text-sm rounded-md transition truncate max-w-xs ${activeTrack?.id === track.id ? 'bg-red-600 text-white font-semibold' : 'bg-gray-700 hover:bg-gray-600 text-gray-300'}`} title={track.title}>{track.title}</button>
                                <button onClick={(e) => { e.stopPropagation(); onDeleteTrack(track.id); }} className="absolute top-0 right-0 h-full px-2 flex items-center text-gray-400 hover:text-white opacity-50 group-hover:opacity-100 transition-opacity" aria-label={`Supprimer ${track.title}`}><XIcon /></button>
                            </div>
                        ))}
                    </div>
                </div>
            )}
            {isPlayerVisible && activeTrack && (
                <div className="mt-4 p-2 bg-gray-900/50 rounded-lg">
                    <div className="flex items-center gap-2 mb-2">
                         <a href={activeTrack.url} target="_blank" rel="noopener noreferrer" title="Ouvrir sur YouTube (garanti de fonctionner)" className="flex items-center justify-center gap-2 text-sm bg-white hover:bg-gray-200 text-black font-bold py-2 px-4 rounded-lg transition">
                            <ExternalLinkIcon /> <span>Ouvrir sur YouTube</span>
                        </a>
                         <button onClick={() => setIsPlayerVisible(false)} className="flex items-center justify-center gap-2 text-sm bg-gray-700 hover:bg-gray-600 text-gray-300 font-semibold py-2 px-3 rounded-lg transition" title="Cacher le lecteur">
                            <EyeOffIcon /> <span>Cacher</span>
                        </button>
                    </div>
                    <div className="bg-black rounded-lg overflow-hidden">
                        <div className="aspect-w-16 aspect-h-9">
                            <iframe key={activeTrack.id} className="w-full h-full aspect-video" src={`https://www.youtube-nocookie.com/embed/${activeTrack.id}?autoplay=1`} title="Lecteur vid√©o YouTube" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen></iframe>
                        </div>
                        <p className="text-xs text-gray-500 p-2 text-center">Si une erreur s'affiche, la lecture est restreinte. Utilisez le bouton "Ouvrir sur YouTube" ci-dessus.</p>
                    </div>
                </div>
            )}
        </div>
    );
};

const InputGrid = ({ chords, onChordChange, onClear, onRandom, activeGridIndex }) => (
    <React.Fragment>
        <div className="flex justify-between items-center mb-2">
            <h2 className="text-lg font-bold text-white">1. Entrez votre grille (1 case = 2 temps)</h2>
            <div className="flex gap-2">
                <button onClick={onRandom} title="G√©n√©rer une grille al√©atoire" className="text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 font-semibold py-1 px-3 rounded-lg transition">üé≤ Al√©atoire</button>
                <button onClick={onClear} title="Vider la grille" className="text-xs bg-red-800/50 hover:bg-red-700 text-white font-semibold py-1 px-3 rounded-lg transition">üóëÔ∏è Vider</button>
            </div>
        </div>
        <div className="grid grid-cols-8 gap-1 mb-3">
            {Array.from({ length: TOTAL_CELLS }).map((_, i) => (
                <input key={i} type="text" value={chords[i]} onChange={(e) => onChordChange(i, e.target.value)} className={`input-grid-cell bg-gray-900 border border-gray-600 rounded-lg w-full p-1 text-center text-sm font-bold text-white transition focus:outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-500/50 ${activeGridIndex === i ? 'cell-active' : ''}`} aria-label={`Accord ${i + 1}`} />
            ))}
        </div>
    </React.Fragment>
);

const NoteDot = ({ cx, cy, noteItem, noteSelection, isPreview, isPlaybackActive }) => {
    const colors = { fondatrice: '#10B981', expressive: '#8B5CF6', preview: '#FBBF24' };
    if (noteSelection) {
        return (
            <g>
                <circle cx={cx} cy={cy} r={9} fill={noteSelection.color} className="note-dot" />
                <text x={cx} y={cy} className="note-dot-text">{noteSelection.chordNumber}</text>
                <text x={cx} y={cy + 15} className="note-name-text">{noteSelection.noteItem.note}</text>
            </g>
        );
    }
    if (noteItem) {
        const fill = isPreview ? colors.preview : (colors[noteItem.type] || '#FFFFFF');
        const className = `note-dot ${!isPreview && isPlaybackActive ? 'note-dot-active' : ''}`;
        return <circle cx={cx} cy={cy} r={9} fill={fill} stroke="#111827" className={className} />;
    }
    return null;
};
const GuitarNeck = ({ pentatonicNotes, displayNotes, notePositions }) => {
    const svgRef = React.useRef(null);
    const [width, setWidth] = React.useState(0);
    React.useEffect(() => {
        const resizeObserver = new ResizeObserver(entries => {
            if (entries[0]) setWidth(entries[0].contentRect.width);
        });
        if (svgRef.current) resizeObserver.observe(svgRef.current);
        return () => resizeObserver.disconnect();
    }, []);
    if (width === 0) {
        return <div className="w-full overflow-x-auto pb-2.5"><svg ref={svgRef} className="w-full h-[170px]"></svg></div>;
    }
    const NECK_WIDTH = width - 50;
    const isPlaybackActive = !!(displayNotes.active || displayNotes.preview);
    const getPosition = (fret) => 50 + ((fret - 0.5) * (NECK_WIDTH / 17));
    const getStringY = (stringIndex) => (140 / 12) * (stringIndex * 2 + 1);
    const fretMarkers = { 3:1, 5:1, 7:1, 9:1, 12:2, 15:1, 17:1 };
    return (
        <div className="w-full overflow-x-auto pb-2.5">
            <svg ref={svgRef} className="w-full h-[170px]">
                <defs><linearGradient id="woodGrain" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style={{stopColor: '#6b4629', stopOpacity: 1}} /><stop offset="100%" style={{stopColor: '#4a2f19', stopOpacity: 1}} /></linearGradient></defs>
                <rect x={0} y={0} width={width} height={140} fill="url(#woodGrain)" />
                <g>{pentatonicNotes.flatMap(note => notePositions.get(note).filter(([, fret]) => fret > 0 && fret <= 17).map(([string, fret], i) => <circle key={`${note}-${string}-${fret}-${i}`} cx={getPosition(fret)} cy={getStringY(string)} r={10} fill="none" stroke="#6B7280" strokeWidth="2" opacity="0.6" />))}</g>
                {Array.from({ length: 18 }).map((_, i) => <line key={`fret-${i}`} x1={50 + (i * (NECK_WIDTH / 17))} y1={getStringY(0)} x2={50 + (i * (NECK_WIDTH / 17))} y2={getStringY(5)} stroke={i === 0 ? '#e5e7eb' : '#a0a0a0'} strokeWidth={i === 0 ? 6 : 3} />)}
                {Array.from({ length: 6 }).map((_, i) => <line key={`string-${i}`} x1={50} y1={getStringY(i)} x2={width} y2={getStringY(i)} stroke="#cbd5e1" strokeWidth={1 + (i * 0.2)} />)}
                {Object.entries(fretMarkers).map(([fret, num]) => {
                    const x = getPosition(parseInt(fret));
                    if (num === 1) return <circle key={`marker-${fret}`} cx={x} cy={70} r={5} fill="#e5e7eb" opacity="0.2" />;
                    return <g key={`marker-${fret}`}><circle cx={x} cy={35} r={5} fill="#e5e7eb" opacity="0.2" /><circle cx={x} cy={105} r={5} fill="#e5e7eb" opacity="0.2" /></g>;
                })}
                {[3, 5, 7, 9, 12, 15, 17].map(fret => <text key={`fret-label-${fret}`} x={getPosition(fret)} y={155} className="fret-number-text">{fret}</text>)}
                <g>
                    {displayNotes.multi ? (
                        displayNotes.multi.flatMap(sel => notePositions.get(sel.noteItem.note).filter(([, fret]) => fret > 0 && fret <= 17).map(([string, fret], i) => <NoteDot key={`note-multi-${sel.chordNumber}-${string}-${fret}-${i}`} cx={getPosition(fret)} cy={getStringY(string)} noteSelection={sel} isPlaybackActive={false} />))
                    ) : (
                        <React.Fragment>
                            {(displayNotes.preview || []).flatMap(item => notePositions.get(item.note).filter(([, fret]) => fret > 0 && fret <= 17).map(([string, fret], i) => <NoteDot key={`note-preview-${item.note}-${string}-${fret}-${i}`} cx={getPosition(fret)} cy={getStringY(string)} noteItem={item} isPreview={true} isPlaybackActive={isPlaybackActive} />))}
                            {(displayNotes.active || []).flatMap(item => notePositions.get(item.note).filter(([, fret]) => fret > 0 && fret <= 17).map(([string, fret], i) => <NoteDot key={`note-active-${item.note}-${string}-${fret}-${i}`} cx={getPosition(fret)} cy={getStringY(string)} noteItem={item} isPlaybackActive={isPlaybackActive} />))}
                        </React.Fragment>
                    )}
                </g>
            </svg>
        </div>
    );
};

const PlayerControls = ({ playbackState, onPlayStop, tempo, onTempoChange, volumes, onVolumeChange }) => {
    const getButtonText = () => {
        switch(playbackState) {
            case PlaybackState.Playing: return 'Stop';
            case PlaybackState.Countdown: return '...';
            case PlaybackState.Stopped: return 'Play';
            default: return 'Play';
        }
    };
    return (
        <div className="mt-3 flex flex-col gap-4 p-3 bg-gray-900/50 rounded-lg">
            <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
                <button id="play-stop-btn" onClick={onPlayStop} disabled={playbackState === PlaybackState.Countdown} className="w-full sm:w-auto bg-emerald-600 hover:bg-emerald-700 disabled:bg-emerald-800 disabled:cursor-not-allowed text-white font-bold py-2 px-6 rounded-lg transition duration-300 flex items-center justify-center gap-2">
                    {playbackState !== PlaybackState.Playing ? <PlayIcon /> : <StopIcon />} <span className="w-16 text-left">{getButtonText()}</span>
                </button>
                <div className="flex items-center gap-2 w-full sm:w-auto">
                    <label htmlFor="tempo-slider" className="font-semibold text-gray-300">Tempo:</label>
                    <input type="range" id="tempo-slider" min="45" max="180" value={tempo} onChange={(e) => onTempoChange(Number(e.target.value))} className="w-full" />
                    <span className="font-bold text-white w-12 text-center">{tempo} bpm</span>
                </div>
            </div>
            <div className="grid grid-cols-3 gap-x-6 gap-y-2 items-center pt-2 border-t border-gray-700/50">
                <div className="flex items-center gap-2 w-full"><MetronomeIcon /><input type="range" title="M√©tronome" min="-48" max="0" value={volumes.metro} onChange={(e) => onVolumeChange('metro', Number(e.target.value))} className="w-full" /></div>
                <div className="flex items-center gap-2 w-full"><BassIcon /><input type="range" title="Basse" min="-48" max="0" value={volumes.bass} onChange={(e) => onVolumeChange('bass', Number(e.target.value))} className="w-full" /></div>
                <div className="flex items-center gap-2 w-full"><ChordIcon /><input type="range" title="Nappes" min="-48" max="0" value={volumes.chord} onChange={(e) => onVolumeChange('chord', Number(e.target.value))} className="w-full" /></div>
            </div>
        </div>
    );
};

const AnalysisCard = ({ analysis, setModalContent, onTargetNoteChange, isSelected, onSelectToggle, selectionColor, isPlaybackActive }) => {
    const handleBadgeClick = (e) => {
        e.stopPropagation();
        let title = '', body = '';
        switch (analysis.front) {
            case 'TENSION': title = 'Front de la Tension (Dominante)'; body = "Cet accord (V7 ou vii¬∞) force le mouvement vers la r√©solution. Votre jeu doit √™tre RAPIDE et AGRESSIF. C'est le moment d'acc√©l√©rer, d'utiliser des notes courtes et de cr√©er une attente."; break;
            case 'OUT_OF_KEY': title = 'Front de la Tension (Hors Tonalit√©)'; body = "Cet accord contient des notes √©trang√®res √† la gamme, cr√©ant un 'choc' harmonique. Il g√©n√®re une tension qui demande √† √™tre g√©r√©e. Consid√©rez-le comme une zone de jeu RAPIDE et SURPRENANTE."; break;
            case 'R√âSOLUTION': title = 'Front de la R√©solution'; body = "Cet accord est une zone de repos, de transition ou de couleur. Votre jeu doit √™tre LENT et LYRIQUE. C'est le moment d'utiliser des phras√©s m√©lodiques et de laisser respirer la musique."; break;
        }
        setModalContent({ title, body });
    };
    const cardClasses = { 'TENSION': 'border-rose-700', 'OUT_OF_KEY': 'border-amber-500', 'R√âSOLUTION': 'border-blue-700' };
    const badgeClasses = { 'TENSION': 'bg-rose-700 text-rose-100', 'OUT_OF_KEY': 'bg-amber-600 text-amber-100', 'R√âSOLUTION': 'bg-blue-700 text-blue-100' };
    return (
        <div className={`p-1 w-1/2 md:w-1/3 lg:w-1/4 transition-transform duration-200 ${isSelected ? 'transform scale-[1.02]' : ''}`}>
            <div className={`relative bg-gray-800 border-2 rounded-lg p-2 flex flex-col h-full space-y-2 transition-all duration-200 ${cardClasses[analysis.front]} ${isSelected ? 'shadow-lg shadow-violet-500/30' : ''}`}>
                 <div onClick={() => onSelectToggle(analysis.analysisIndex)} className={`absolute top-2 left-2 w-4 h-4 rounded-full border-2 transition-all duration-200 ${isPlaybackActive ? 'cursor-not-allowed bg-gray-700 border-gray-600' : 'cursor-pointer'}`} style={{ borderColor: isSelected ? selectionColor : '#6b7280', backgroundColor: isSelected ? selectionColor : 'transparent' }}></div>
                <div className="flex-shrink-0">
                    <div className="flex justify-between items-start mb-1">
                        <h3 className="text-lg font-extrabold text-white pl-6">{analysis.accord} <span className="text-base font-semibold text-gray-400">{analysis.degre}</span></h3>
                        <span onClick={handleBadgeClick} className={`inline-block px-2.5 py-0.5 rounded-full font-semibold text-xs text-center cursor-pointer transition transform hover:scale-105 ${badgeClasses[analysis.front]}`}>{analysis.front === 'OUT_OF_KEY' ? 'HORS TONALIT√â' : analysis.front}</span>
                    </div>
                    <p className={`text-[11px] font-semibold ${analysis.front === 'R√âSOLUTION' ? 'text-blue-300' : 'text-rose-300'}`}>{analysis.actionRythmique}</p>
                </div>
                <div className="flex-grow space-y-2">
                    <div>
                        <p className="text-[11px] text-violet-400 font-bold tracking-wider mb-1">CHOISIR UNE NOTE CIBLE</p>
                        <div className="space-y-1">
                            {analysis.allTargetOptions.map((item, index) => {
                                const id = `target-${analysis.analysisIndex}-${index}`;
                                const isChecked = analysis.selectedNote?.note === item.note && analysis.selectedNote?.interval === item.interval;
                                return (
                                    <div key={id}>
                                        <input type="radio" name={`target-choice-${analysis.analysisIndex}`} id={id} value={index} className="hidden" checked={isChecked} onChange={() => onTargetNoteChange(analysis.analysisIndex, index)} />
                                        <label htmlFor={id} className={`block cursor-pointer p-2 rounded-md border transition-all ${isChecked ? 'bg-violet-800 border-violet-400 text-white' : 'bg-gray-500/20 border-gray-600 hover:bg-gray-500/40 hover:border-gray-500'}`}>
                                            <span className="font-bold text-sm">{item.note} ({item.interval})</span> - <span className="text-gray-400 text-xs">{item.intention}</span>
                                        </label>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};

const AnalysisSection = ({ keySignature, scaleNotes, analysisResults, setModalContent, onTargetNoteChange, onCardSelectionChange, isPlaybackActive }) => {
    const [selectedCardIndices, setSelectedCardIndices] = React.useState(new Set());
    const multiSelectColors = ['#FBBF24', '#34D399', '#F87171', '#60A5FA', '#EC4899', '#8B5CF6'];
    const handleExport = () => {
        if (analysisResults.length === 0) return;
        const headers = ['Accord', 'Degr√©', 'Front GIA', 'Action Rythmique', 'Note Cible Choisie', 'Intention Choisie', 'Intervalle Cible'];
        const rows = analysisResults.map(res => {
            if (!res.accord) return null;
            const selected = res.selectedNote;
            return [`"${res.accord}"`, `"${res.degre}"`, `"${res.front}"`, `"${res.actionRythmique}"`, selected ? `"${selected.note}"` : '""', selected ? `"${selected.intention}"` : '""', selected ? `"${selected.interval}"` : '""'];
        }).filter(row => row !== null);
        const csvContent = "data:text/csv;charset=utf-8," + headers.join(",") + "\n" + rows.map(e => e.join(",")).join("\n");
        const link = document.createElement("a");
        link.setAttribute("href", encodeURI(csvContent));
        link.setAttribute("download", "analyse_gia_navigator.csv");
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    };
    const handleCardSelectToggle = (analysisIndex) => {
        if (isPlaybackActive) return;
        const newSet = new Set(selectedCardIndices);
        if (newSet.has(analysisIndex)) { newSet.delete(analysisIndex); } else { newSet.add(analysisIndex); }
        setSelectedCardIndices(newSet);
    };
    React.useEffect(() => { if (isPlaybackActive) setSelectedCardIndices(new Set()); }, [isPlaybackActive]);
    React.useEffect(() => {
        const selections = [];
        const selectedArray = Array.from(selectedCardIndices);
        selectedArray.forEach((analysisIndex, i) => {
            const analysis = analysisResults.find(r => r.analysisIndex === analysisIndex);
            if (analysis && analysis.selectedNote) {
                selections.push({
                    noteItem: analysis.selectedNote,
                    chordNumber: analysis.analysisIndex + 1,
                    color: multiSelectColors[i % multiSelectColors.length],
                });
            }
        });
        onCardSelectionChange(selections);
    }, [selectedCardIndices, analysisResults, onCardSelectionChange]);
    return (
        <div className="p-3 bg-gray-800/50 rounded-xl border border-gray-700">
            <div className="flex flex-col sm:flex-row justify-between sm:items-start mb-2 gap-3">
                <div>
                    <h2 className="text-lg font-bold text-white">2. Votre Plan d'Action GIA</h2>
                    <div className="flex items-center flex-wrap gap-x-4 gap-y-2 mt-2">
                        <p className="text-blue-300 font-semibold">{keySignature ? `Tonalit√©: ${keySignature.name}` : 'En attente d\'un accord...'}</p>
                        {keySignature && <div className="flex items-center gap-3 bg-gray-700 px-3 py-1 rounded-md text-sm font-semibold text-gray-300">{scaleNotes.map(note => <span key={note} className={note === keySignature.root ? 'text-blue-400 font-extrabold' : ''}>{note}</span>)}</div>}
                    </div>
                </div>
                {analysisResults.length > 0 && <div className="flex flex-col items-end gap-2 self-stretch"><button onClick={handleExport} className="w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Exporter (CSV)</button></div>}
            </div>
            <div className="flex flex-wrap -m-1">
                {analysisResults.map((result) => <AnalysisCard key={result.gridIndex} analysis={result} setModalContent={setModalContent} onTargetNoteChange={onTargetNoteChange} isSelected={selectedCardIndices.has(result.analysisIndex)} onSelectToggle={handleCardSelectToggle} selectionColor={multiSelectColors[Array.from(selectedCardIndices).indexOf(result.analysisIndex) % multiSelectColors.length]} isPlaybackActive={isPlaybackActive} />)}
            </div>
        </div>
    );
};

const InfoModal = ({ modalContent, setModalContent }) => {
    React.useEffect(() => {
        const handleEsc = (event) => { if (event.key === 'Escape') setModalContent(null); };
        window.addEventListener('keydown', handleEsc);
        return () => window.removeEventListener('keydown', handleEsc);
    }, [setModalContent]);
    if (!modalContent) return null;
    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 transition-opacity duration-300 ease-in-out">
            <div className="absolute inset-0" onClick={() => setModalContent(null)}></div>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md z-10 transform transition-all duration-300 ease-in-out scale-100 opacity-100">
                <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-bold text-white">{modalContent.title}</h3>
                    <button onClick={() => setModalContent(null)} className="text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
                </div>
                <p className="text-gray-300">{modalContent.body}</p>
            </div>
        </div>
    );
};


// ====================================================================================
// START: App.js (Main Component)
// ====================================================================================

const App = () => {
    const [chords, setChords] = React.useState(Array(TOTAL_CELLS).fill(''));
    const [analysisResults, setAnalysisResults] = React.useState([]);
    const [key, setKey] = React.useState(null);
    const [scaleNotes, setScaleNotes] = React.useState([]);
    const [pentatonicNotes, setPentatonicNotes] = React.useState([]);
    const [playbackState, setPlaybackState] = React.useState(PlaybackState.Stopped);
    const [tempo, setTempo] = React.useState(45);
    const [volumes, setVolumes] = React.useState({ metro: -12, bass: -6, chord: -14 });
    const [modalContent, setModalContent] = React.useState(null);
    const [activeGridIndex, setActiveGridIndex] = React.useState(-1);
    const [neckNotes, setNeckNotes] = React.useState({});
    const [notePositions] = React.useState(() => new NotePositions());
    const [activeYoutubeTrack, setActiveYoutubeTrack] = React.useState(null);
    const [savedYoutubeTracks, setSavedYoutubeTracks] = React.useState([]);
    const [level, setLevel] = React.useState(1);
    const [xp, setXp] = React.useState(0);
    const [practiceTime, setPracticeTime] = React.useState(0);
    
    const toneService = React.useRef(null);
    const practiceTimerRef = React.useRef(null);
    
    const xpForNextLevel = level * 100;
    const PRACTICE_TIME_GOAL_SECONDS = 15 * 60;
    const XP_PER_ACTION = 10;

    const addXp = React.useCallback((amount) => {
        setXp(currentXp => {
            const neededXp = level * 100;
            const newXp = currentXp + amount;
            if (newXp >= neededXp) {
                setLevel(currentLevel => currentLevel + 1);
                return newXp - neededXp;
            }
            return newXp;
        });
    }, [level]);
    
    React.useEffect(() => {
        const savedTracksJSON = localStorage.getItem('gia-youtube-tracks');
        if (savedTracksJSON) {
            try {
                const tracks = JSON.parse(savedTracksJSON);
                setSavedYoutubeTracks(tracks);
                if (tracks.length > 0) setActiveYoutubeTrack(tracks[0]);
            } catch (e) { console.error("Failed to parse saved YouTube tracks", e); }
        }
    }, []);

    React.useEffect(() => {
        if (playbackState === PlaybackState.Playing) {
            practiceTimerRef.current = window.setInterval(() => {
                setPracticeTime(prevTime => {
                    const newTime = prevTime + 1;
                    if (newTime % 10 === 0) addXp(1);
                    return newTime;
                });
            }, 1000);
        } else {
            if (practiceTimerRef.current) clearInterval(practiceTimerRef.current);
        }
        return () => { if (practiceTimerRef.current) clearInterval(practiceTimerRef.current); };
    }, [playbackState, addXp]);

    const updateAnalysis = React.useCallback(() => {
        const { key: newKey, results } = analyzeProgression(chords, notePositions);
        setKey(newKey);
        setAnalysisResults(results);
        if (newKey) {
            setScaleNotes(getScaleNotes(newKey));
            setPentatonicNotes(getPentatonicScaleNotes(newKey, notePositions));
        } else {
            setScaleNotes([]);
            setPentatonicNotes([]);
        }
    }, [chords, notePositions]);

    React.useEffect(() => { updateAnalysis(); }, [chords, updateAnalysis]);

    React.useEffect(() => {
        if (playbackState === PlaybackState.Stopped) {
            const firstSelectedNote = analysisResults.find(r => r.selectedNote)?.selectedNote;
            setNeckNotes(firstSelectedNote ? { active: [firstSelectedNote] } : {});
        }
    }, [playbackState, analysisResults]);
    
    const updateNeckForPlayback = React.useCallback((gridIndex) => {
        let currentAnalysis = null;
        for (let i = gridIndex; i >= 0; i--) {
            const analysis = analysisResults.find(a => a.gridIndex === i);
            if (analysis) { currentAnalysis = analysis; break; }
        }
        if (!currentAnalysis) { setNeckNotes({}); return; }
        const nextAnalysis = analysisResults.find(a => a.analysisIndex === currentAnalysis.analysisIndex + 1) || analysisResults[0];
        setNeckNotes({
            active: currentAnalysis.selectedNote ? [currentAnalysis.selectedNote] : [],
            preview: nextAnalysis?.selectedNote ? [nextAnalysis.selectedNote] : []
        });
    }, [analysisResults]);

    const handlePlayStop = React.useCallback(async () => {
        if (!toneService.current) {
            await Tone.start();
            const newToneService = new ToneService(setActiveGridIndex, setPlaybackState, (index) => updateNeckForPlayback(index));
            await newToneService.init();
            toneService.current = newToneService;
            toneService.current.setTempo(tempo);
            Object.entries(volumes).forEach(([instrument, volume]) => toneService.current?.setVolume(instrument, volume));
        }
        if (playbackState !== PlaybackState.Stopped) {
            toneService.current?.stop();
        } else {
            const firstChord = chords.find(c => c.trim() !== '');
            if (firstChord) {
                addXp(XP_PER_ACTION * 2);
                toneService.current?.play(chords, analysisResults, notePositions);
            }
        }
    }, [playbackState, chords, analysisResults, notePositions, addXp, updateNeckForPlayback, tempo, volumes]);

    const handleTempoChange = React.useCallback((newTempo) => {
        setTempo(newTempo);
        toneService.current?.setTempo(newTempo);
    }, []);

    const handleVolumeChange = React.useCallback((instrument, volume) => {
        setVolumes(prev => ({ ...prev, [instrument]: volume }));
        toneService.current?.setVolume(instrument, volume);
    }, []);
    
    const handleChordChange = React.useCallback((index, value) => {
        const newChords = [...chords];
        if (newChords[index] !== value) addXp(XP_PER_ACTION);
        newChords[index] = value;
        setChords(newChords);
    }, [chords, addXp]);

    const handleClearGrid = React.useCallback(() => { setChords(Array(TOTAL_CELLS).fill('')); }, []);

    const handleRandomGrid = React.useCallback(() => {
        addXp(XP_PER_ACTION);
        const randomProg = PRESET_PROGRESSIONS[Math.floor(Math.random() * PRESET_PROGRESSIONS.length)];
        const newChords = Array(TOTAL_CELLS).fill('');
        randomProg.chords.forEach((chord, i) => { if (i < newChords.length) newChords[i] = chord; });
        setChords(newChords);
    }, [addXp]);
    
    const handleTargetNoteChange = React.useCallback((analysisIndex, optionIndex) => {
        const currentResult = analysisResults.find(res => res.analysisIndex === analysisIndex);
        if (currentResult?.selectedNote !== currentResult?.allTargetOptions[optionIndex]) addXp(XP_PER_ACTION);
        const newResults = analysisResults.map(res => (res.analysisIndex === analysisIndex) ? { ...res, selectedNote: res.allTargetOptions[optionIndex] } : res);
        setAnalysisResults(newResults);
    }, [analysisResults, addXp]);

    const handleCardSelectionChange = (newSelections) => {
        if (newSelections.length > 0) {
            setNeckNotes({ multi: newSelections });
        } else if (playbackState === PlaybackState.Stopped) {
            const firstSelectedNote = analysisResults.find(r => r.selectedNote)?.selectedNote;
            setNeckNotes(firstSelectedNote ? { active: [firstSelectedNote] } : {});
        }
    };
    
    const handleSaveYouTubeTrack = (newTrack) => {
        setSavedYoutubeTracks(currentTracks => {
            if (currentTracks.some(track => track.id === newTrack.id)) return currentTracks;
            const updatedTracks = [...currentTracks, newTrack];
            localStorage.setItem('gia-youtube-tracks', JSON.stringify(updatedTracks));
            return updatedTracks;
        });
        setActiveYoutubeTrack(newTrack);
    };

    const handleDeleteYouTubeTrack = (trackId) => {
        setSavedYoutubeTracks(currentTracks => {
            const updatedTracks = currentTracks.filter(track => track.id !== trackId);
            localStorage.setItem('gia-youtube-tracks', JSON.stringify(updatedTracks));
            if (activeYoutubeTrack?.id === trackId) {
                setActiveYoutubeTrack(updatedTracks.length > 0 ? updatedTracks[0] : null);
            }
            return updatedTracks;
        });
    };

    return (
        <div className="min-h-screen flex flex-col items-center">
            <div className="w-full max-w-7xl mx-auto relative">
                <Header />
                 <GamificationHeader level={level} xp={xp} xpForNextLevel={xpForNextLevel} practiceTime={practiceTime} practiceTimeGoal={PRACTICE_TIME_GOAL_SECONDS} />
                <div className="mb-2 p-3 bg-gray-800/50 rounded-xl border border-gray-700">
                    <YouTubeBackingTrack activeTrack={activeYoutubeTrack} savedTracks={savedYoutubeTracks} onSaveTrack={handleSaveYouTubeTrack} onSelectTrack={setActiveYoutubeTrack} onDeleteTrack={handleDeleteYouTubeTrack} />
                    <InputGrid chords={chords} onChordChange={handleChordChange} onClear={handleClearGrid} onRandom={handleRandomGrid} activeGridIndex={activeGridIndex} />
                    <GuitarNeck pentatonicNotes={pentatonicNotes} displayNotes={neckNotes} notePositions={notePositions} />
                    <PlayerControls playbackState={playbackState} onPlayStop={handlePlayStop} tempo={tempo} onTempoChange={handleTempoChange} volumes={volumes} onVolumeChange={handleVolumeChange} />
                </div>
                <AnalysisSection keySignature={key} scaleNotes={scaleNotes} analysisResults={analysisResults} setModalContent={setModalContent} onTargetNoteChange={handleTargetNoteChange} onCardSelectionChange={handleCardSelectionChange} isPlaybackActive={playbackState !== PlaybackState.Stopped} />
                <footer className="text-center mt-4 text-gray-500 text-sm"><p>D√©velopp√© pour la Guitare Impro Acad√©mie par Fran√ßois.</p></footer>
            </div>
            <InfoModal modalContent={modalContent} setModalContent={setModalContent} />
        </div>
    );
};

// ====================================================================================
// START: Render App
// ====================================================================================

const rootElement = document.getElementById('root');
const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

    </script>
</body>
</html>
