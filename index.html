<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GIA Navigator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
      body {
        font-family: 'Inter', sans-serif;
      }
      .input-grid-cell.cell-active {
        box-shadow: 0 0 0 3px #3B82F6;
        border-color: #3B82F6;
      }
      .note-dot {
        transition: all 0.2s;
        stroke-width: 2;
      }
      @keyframes pulse-note {
        0% { r: 9; opacity: 1; }
        50% { r: 11; opacity: 0.8; }
        100% { r: 9; opacity: 1; }
      }
      .note-dot-active {
        animation: pulse-note 1s infinite;
      }
      .note-dot-text {
        font-size: 10px;
        font-weight: bold;
        fill: #111827; /* gray-900 */
        pointer-events: none;
        text-anchor: middle;
        dominant-baseline: central;
      }
      .note-name-text {
        font-size: 8px;
        font-weight: 500;
        fill: #f3f4f6; /* gray-100 */
        pointer-events: none;
        text-anchor: middle;
      }
      .fret-number-text {
        font-size: 10px;
        font-weight: bold;
        fill: #9ca3af; /* gray-400 */
        text-anchor: middle;
      }
      @keyframes slide-in-bottom-right {
        from {
          transform: translate(50%, 50%);
          opacity: 0;
        }
        to {
          transform: translate(0, 0);
          opacity: 1;
        }
      }
      .animate-slide-in {
        animation: slide-in-bottom-right 0.3s ease-out;
      }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 p-2 sm:p-4">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>

    <script type="text/babel">
    
// ====================================================================================
// START: constants.js
// ====================================================================================

const NOTES = {
    sharp: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
    flat:  ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B']
};
const MAJOR_SCALE_INTERVALS = [0, 2, 4, 5, 7, 9, 11];
const MINOR_PENTATONIC_INTERVALS = [0, 3, 5, 7, 10];
const MAJOR_PENTATONIC_INTERVALS = [0, 2, 4, 7, 9];
const TOTAL_CELLS = 24;
const TUNING = ['E', 'A', 'D', 'G', 'B', 'E'];
const PRESET_PROGRESSIONS = [
    { name: "Pop/Rock Mineur", chords: ['Am', '', 'G', '', 'D', '', 'E', ''] },
    { name: "Jazz ii-V-I (Majeur)", chords: ['Dm7', '', 'G7', '', 'Cmaj7', ''] },
    { name: "Pop/Rock Majeur", chords: ['C', '', 'G', '', 'Am', '', 'F', ''] },
    { name: "Blues 12 Mesures (en A)", chords: ['A7','','A7','','A7','','A7','','D7','','D7','','A7','','A7','','E7','','D7','','A7','','A7',''] }
];
const ZONES = [
    { label: 'Tout le manche', min: 0, max: 18 },
    { label: 'Cases 0-5', min: 0, max: 5 },
    { label: 'Cases 5-9', min: 5, max: 9 },
    { label: 'Cases 9-12', min: 9, max: 12 },
    { label: 'Cases 12-17', min: 12, max: 17 }
];
const PlaybackState = {
    Stopped: 'Stopped',
    Countdown: 'Countdown',
    Playing: 'Playing',
};

// ====================================================================================
// START: services/musicTheory.js
// ====================================================================================

class NotePositions {
    positions = {};
    constructor() { this.calculateNotePositions(); }
    calculateNotePositions() {
        NOTES.sharp.forEach(note => this.positions[note] = []);
        NOTES.flat.forEach(note => this.positions[note] = []);
        for (let stringIndex = 0; stringIndex < 6; stringIndex++) {
            const openStringNote = TUNING[5 - stringIndex];
            let currentNoteIndex = getNoteInfo(openStringNote).index;
            for (let fret = 0; fret <= 17; fret++) {
                const noteNameSharp = NOTES.sharp[currentNoteIndex % 12];
                const noteNameFlat = NOTES.flat[currentNoteIndex % 12];
                if (!this.positions[noteNameSharp]) this.positions[noteNameSharp] = [];
                this.positions[noteNameSharp].push([stringIndex, fret]);
                if (noteNameSharp !== noteNameFlat) {
                     if (!this.positions[noteNameFlat]) this.positions[noteNameFlat] = [];
                     this.positions[noteNameFlat].push([stringIndex, fret]);
                }
                currentNoteIndex++;
            }
        }
    }
    get(note) { return this.positions[note] || []; }
}

function getNoteInfo(noteName) {
    if (!noteName || typeof noteName !== 'string') return { root: '?', index: -1 };
    const match = noteName.match(/^([A-G])([#b]?)/);
    if (!match) return { root: '?', index: -1 };
    const root = match[0];
    const sharpIndex = NOTES.sharp.indexOf(root);
    const flatIndex = NOTES.flat.indexOf(root);
    if (sharpIndex !== -1) return { root, index: sharpIndex };
    if (flatIndex !== -1) return { root, index: flatIndex };
    const map = { 'A#': 'Bb', 'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab' };
    const equivalentFlat = map[root] || root;
    const index = NOTES.flat.indexOf(equivalentFlat);
    return { root, index };
}

function getChordQuality(chordName) {
    if (!chordName) return '';
    if (chordName.includes('maj7') || chordName.includes('M7') || chordName.includes('Œî')) return 'major7';
    if (chordName.includes('m7') || chordName.includes('min7')) return 'minor7';
    if (chordName.includes('¬∞7') || chordName.includes('dim7')) return 'diminished7';
    if (chordName.includes('dim') || chordName.includes('¬∞')) return 'diminished';
    if (chordName.includes('m') && !chordName.includes('maj')) return 'minor';
    if (chordName.includes('7')) return 'dominant7';
    return 'major';
}

function getIntervalNote(rootNote, semitones, key) {
    const rootInfo = getNoteInfo(rootNote);
    if (rootInfo.index === -1) return '?';
    const noteArray = key.keySignatureType === 'flat' ? NOTES.flat : NOTES.sharp;
    const targetIndex = (rootInfo.index + semitones) % 12;
    return noteArray[targetIndex];
}

function findDegree(chordName, key) {
    const chordRootInfo = getNoteInfo(chordName);
    if (chordRootInfo.index === -1) return '?';
    const keyRootIndex = getNoteInfo(key.root).index;
    if (keyRootIndex === -1) return '?';
    const quality = getChordQuality(chordName);
    const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];
    const interval = (chordRootInfo.index - keyRootIndex + 12) % 12;
    let degree = '?'; let alteration = '';
    const referenceIntervals = MAJOR_SCALE_INTERVALS;
    for (let i = 0; i < referenceIntervals.length; i++) {
        const scaleInterval = referenceIntervals[i];
        if (interval === scaleInterval) { degree = romanNumerals[i]; break; }
        if (interval === scaleInterval - 1) { alteration = 'b'; degree = romanNumerals[i]; break; }
        if (i > 0 && interval === referenceIntervals[i-1] + 1) { 
            if(interval === 3) continue; 
            alteration = '#'; degree = romanNumerals[i-1]; break; 
        }
    }
    if (degree === '?') {
         if (interval === 6) { alteration = '#'; degree = 'IV'; }
         else { return '?'; }
    }
    if (quality.includes('minor')) { degree = degree.toLowerCase(); }
    else if (quality.includes('diminished')) { degree = degree.toLowerCase() + '¬∞'; }
    return alteration + degree;
}

function getScaleNotes(key) {
    const noteArray = key.keySignatureType === 'flat' ? NOTES.flat : NOTES.sharp;
    const intervals = key.type === 'major' ? MAJOR_SCALE_INTERVALS : [0, 2, 3, 5, 7, 8, 10];
    const rootIndex = getNoteInfo(key.root).index;
    if (rootIndex === -1) return [];
    return intervals.map(i => noteArray[(rootIndex + i) % 12]);
}

function getPentatonicScaleNotes(key, notePositions) {
    const noteArray = key.keySignatureType === 'flat' ? NOTES.flat : NOTES.sharp;
    const intervals = key.type === 'major' ? MAJOR_PENTATONIC_INTERVALS : MINOR_PENTATONIC_INTERVALS;
    const rootIndex = getNoteInfo(key.root).index;
    if (rootIndex === -1) return [];
    return intervals.map(i => noteArray[(rootIndex + i) % 12]);
}

function getChordTones(chordName, key) {
    const noteInfo = getNoteInfo(chordName);
    const quality = getChordQuality(chordName);
    if(noteInfo.index === -1) return [];
    const root = noteInfo.root;
    const thirdInterval = quality.includes('minor') || quality.includes('diminished') ? 3 : 4;
    const fifthInterval = quality.includes('diminished') ? 6 : 7;
    const third = getIntervalNote(root, thirdInterval, key);
    const fifth = getIntervalNote(root, fifthInterval, key);
    let tones = [root, third, fifth];
    if (quality.includes('7')) {
        let seventhInterval;
        if(quality === 'major7') seventhInterval = 11;
        else if (quality === 'diminished7') seventhInterval = 9;
        else seventhInterval = 10;
        tones.push(getIntervalNote(root, seventhInterval, key));
    }
    return tones;
}

function checkIfOutOfKey(chordName, key, degree) {
    const scaleNotes = getScaleNotes(key);
    if (!scaleNotes.length) return false;
    const scaleNotesIndices = scaleNotes.map(n => getNoteInfo(n).index);
    const chordTonesNotes = getChordTones(chordName, key);
    for (const tone of chordTonesNotes) {
        const toneIndex = getNoteInfo(tone).index;
        if (!scaleNotesIndices.includes(toneIndex)) {
            if (key.type === 'minor' && degree.toUpperCase().replace(/[#b]/g, '') === 'V') {
                 const harmonicMinorLeadingToneIndex = (getNoteInfo(key.root).index + 11) % 12;
                 if (toneIndex === harmonicMinorLeadingToneIndex) continue;
            }
            return true;
        }
    }
    return false;
}

function analyzeSingleChord(chordName, key, nextChordName) {
    const noteInfo = getNoteInfo(chordName);
    const quality = getChordQuality(chordName);
    const degree = findDegree(chordName, key);
    const isOutOfKey = checkIfOutOfKey(chordName, key, degree);
    const isPotentiallyDominant = (degree.replace(/[#b]/g, '').toUpperCase() === 'V');
    let isConfirmedDominant = false;
    if (isPotentiallyDominant) {
        const currentRootIndex = getNoteInfo(chordName).index;
        const nextRootIndex = getNoteInfo(nextChordName).index;
        if (currentRootIndex !== -1 && nextRootIndex !== -1 && (currentRootIndex - nextRootIndex + 12) % 12 === 7) {
            isConfirmedDominant = true;
        }
    }
    let front;
    if (isConfirmedDominant) { front = 'TENSION'; }
    else if (isOutOfKey) { front = 'OUT_OF_KEY'; }
    else { front = 'R√âSOLUTION'; }
    const actionRythmique = front === 'TENSION' || front === 'OUT_OF_KEY' ? 'RAPIDE / AGRESSIF' : 'LENT / LYRIQUE';
    
    // NOUVELLE LOGIQUE : Uniquement les notes de l'accord (R, 3, 5, 7)
    let chordTones = [];
    
    // Fondamentale
    chordTones.push({ 
        note: noteInfo.root, 
        interval: 'R', 
        type: 'fondatrice', 
        intention: 'Fondamentale' 
    });

    // Tierce
    const thirdInterval = quality.includes('minor') || quality.includes('diminished') ? 3 : 4;
    const thirdNote = getIntervalNote(noteInfo.root, thirdInterval, key);
    chordTones.push({
        note: thirdNote,
        interval: quality.includes('minor') || quality.includes('diminished') ? '3m' : '3M',
        type: 'fondatrice',
        intention: 'Tierce'
    });

    // Quinte
    const fifthInterval = quality.includes('diminished') ? 6 : 7;
    const fifthNote = getIntervalNote(noteInfo.root, fifthInterval, key);
    chordTones.push({
        note: fifthNote,
        interval: quality.includes('diminished') ? '5dim' : '5J',
        type: 'fondatrice',
        intention: 'Quinte'
    });

    // Septi√®me (si applicable)
    if (quality.includes('7') || quality.includes('maj7') || quality.includes('m7') || quality.includes('dim7')) {
        let seventhInterval;
        let intervalName;
        if(quality === 'major7') { seventhInterval = 11; intervalName = '7M'; }
        else if (quality === 'diminished7') { seventhInterval = 9; intervalName = '7dim'; }
        else { seventhInterval = 10; intervalName = 'b7'; } // dominant or minor 7

        const seventhNote = getIntervalNote(noteInfo.root, seventhInterval, key);
        chordTones.push({
            note: seventhNote,
            interval: intervalName,
            type: 'fondatrice',
            intention: 'Septi√®me'
        });
    }

    // Le tableau allTargetOptions contient maintenant strictement les notes de l'accord
    const allTargetOptions = [...chordTones];
    
    return { accord: chordName, degre: degree, front, actionRythmique, allTargetOptions };
}

function detectKey(firstChord) {
    const { root } = getNoteInfo(firstChord);
    const quality = getChordQuality(firstChord);
    const flatKeys = ['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb'];
    const flatMinorKeys = ['Dm', 'Gm', 'Cm', 'Fm', 'Bbm', 'Ebm']; 
    let keySignatureType = 'sharp';
    if (flatKeys.includes(root) || flatMinorKeys.includes(root+'m') || root.includes('b')) {
        keySignatureType = 'flat';
    }
    if (quality.includes('minor')) {
        return { name: `${root} mineur`, root: root, type: 'minor', keySignatureType };
    }
    return { name: `${root} Majeur`, root: root, type: 'major', keySignatureType };
}

function analyzeProgression(chords, notePositions) {
    const firstChord = chords.find(c => c.trim());
    if (!firstChord) {
        return { key: null, results: [] };
    }
    const key = detectKey(firstChord);
    const results = [];
    const activeChordsWithIndices = chords
        .map((chord, index) => ({ chord: chord.trim(), index }))
        .filter(item => item.chord !== '');
    if (activeChordsWithIndices.length > 0) {
        activeChordsWithIndices.forEach((chordItem, activeIndex) => {
            const nextChordItem = activeChordsWithIndices[activeIndex + 1] || activeChordsWithIndices[0];
            const analysis = analyzeSingleChord(chordItem.chord, key, nextChordItem.chord);
            const fundamentalNote = analysis.allTargetOptions.find(opt => opt.interval === 'R');
            results.push({
                ...analysis,
                gridIndex: chordItem.index,
                analysisIndex: activeIndex,
                selectedNote: fundamentalNote
            });
        });
    }
    return { key, results };
}

// ====================================================================================
// START: services/toneService.js
// ====================================================================================

class ToneService {
    bassSynth; chordSynth; metronome;
    part = null; countdownPart = null;
    currentLoopEndMeasures = 0;
    setActiveGridIndex; setPlaybackState; updateNeckCallback;
    constructor(setActiveGridIndex, setPlaybackState, updateNeckCallback) {
        this.setActiveGridIndex = setActiveGridIndex;
        this.setPlaybackState = setPlaybackState;
        this.updateNeckCallback = updateNeckCallback;
    }
    async init() {
        this.bassSynth = new Tone.MonoSynth({
            oscillator: { type: 'fatsawtooth' },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 },
            filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.8, baseFrequency: 200, octaves: 4 }
        }).toDestination();
        this.chordSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "fatsawtooth", count: 3, spread: 30 },
            envelope: { attack: 0.05, decay: 0.1, sustain: 0.7, release: 0.8 }
        }).toDestination();
        this.metronome = new Tone.MembraneSynth({
            pitchDecay: 0.01,
            octaves: 10,
            oscillator: { type: 'square' },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 }
        }).toDestination();
    }
    setTempo(bpm) { Tone.Transport.bpm.value = bpm; }
    setVolume(instrument, value) {
        if (!this.bassSynth) return;
        switch (instrument) {
            case 'bass': this.bassSynth.volume.value = value; break;
            case 'chord': this.chordSynth.volume.value = value; break;
            case 'metro': this.metronome.volume.value = value; break;
        }
    }
    updateSchedule(chords, analysisResults, notePositions) {
        if (this.part) this.part.dispose();
        const lastChordIndex = chords.map(c => c.trim()).lastIndexOf(chords.filter(c => c.trim()).pop() || '');
        if (lastChordIndex === -1) { this.currentLoopEndMeasures = 0; return; }
        const totalBeatsInProgression = (lastChordIndex + 1) * 2;
        const loopEndMeasures = Math.ceil(totalBeatsInProgression / 4);
        this.currentLoopEndMeasures = loopEndMeasures;
        const totalLoopBeats = loopEndMeasures * 4;
        const events = [];
        for (let i = 0; i <= lastChordIndex; i++) {
            const chordName = chords[i];
            if (chordName) {
                const beat = i * 2;
                const time = `${Math.floor(beat / 4)}:${beat % 4}:0`;
                const { root: rootNote } = getNoteInfo(chordName);
                if (rootNote !== '?') {
                    let nextChangeIndex = -1;
                    for (let j = i + 1; j <= lastChordIndex; j++) { if (chords[j]) { nextChangeIndex = j; break; } }
                    const endTimeBeats = (nextChangeIndex !== -1) ? nextChangeIndex * 2 : totalLoopBeats;
                    const durationBeats = endTimeBeats - beat;
                    if (durationBeats > 0) {
                        const durationNotation = `${Math.floor(durationBeats / 4)}:${durationBeats % 4}:0`;
                        events.push({ time, note: rootNote + '2', duration: durationNotation, type: 'bass' });
                        const analysis = analysisResults.find(r => r.gridIndex === i);
                        if(analysis) {
                            const chordTones = analysis.allTargetOptions.filter(o => o.type === 'fondatrice' && o.interval !== 'b7').map(n => n.note + '4');
                             if (chordTones.length > 0) {
                                events.push({ time, notes: chordTones, duration: durationNotation, type: 'chord' });
                            }
                        }
                    }
                }
            }
        }
        const loopEndCells = this.currentLoopEndMeasures * 2;
        for (let i = 0; i < loopEndCells; i++) {
            const beat = i * 2;
            const time = `${Math.floor(beat / 4)}:${beat % 4}:0`;
            events.push({ time, gridIndex: i, type: 'highlight' });
        }
        for (let beat = 0; beat < totalLoopBeats; beat++) {
            const time = `${Math.floor(beat / 4)}:${beat % 4}:0`;
            events.push({ time, note: beat % 4 === 0 ? 'C5' : 'C4', type: 'metro' });
        }
        events.sort((a, b) => Tone.Time(a.time).toSeconds() - Tone.Time(b.time).toSeconds());
        if (events.length > 0 && loopEndMeasures > 0) {
            this.part = new Tone.Part((time, value) => {
                if (value.type === 'bass') { this.bassSynth.triggerAttackRelease(value.note, value.duration, time); }
                else if (value.type === 'chord') { this.chordSynth.triggerAttackRelease(value.notes, value.duration, time); }
                else if (value.type === 'metro') { this.metronome.triggerAttackRelease(value.note, '16n', time); }
                else if (value.type === 'highlight') {
                    Tone.Draw.schedule(() => {
                        this.setActiveGridIndex(value.gridIndex);
                        this.updateNeckCallback(value.gridIndex);
                    }, time);
                }
            }, events).start("1m");
            this.part.loop = true;
            this.part.loopEnd = `${loopEndMeasures}m`;
        }
    }
    play(chords, analysisResults, notePositions) {
        this.updateSchedule(chords, analysisResults, notePositions);
        if (this.currentLoopEndMeasures === 0) return;
        this.setPlaybackState(PlaybackState.Countdown);
        const countdownEvents = [{ time: '0:0', count: 4 }, { time: '0:1', count: 3 }, { time: '0:2', count: 2 }, { time: '0:3', count: 1 }];
        if (this.countdownPart) this.countdownPart.dispose();
        this.countdownPart = new Tone.Part((time, value) => { this.metronome.triggerAttackRelease('C5', '8n', time); }, countdownEvents).start(0);
        this.countdownPart.loop = false;
        Tone.Transport.scheduleOnce(() => { this.setPlaybackState(PlaybackState.Playing); }, '1m'); 
        Tone.Transport.loop = true;
        Tone.Transport.loopStart = '1m';
        Tone.Transport.loopEnd = `${this.currentLoopEndMeasures + 1}m`;
        Tone.Transport.start();
    }
    stop() {
        if (this.countdownPart) { this.countdownPart.stop(0); this.countdownPart.dispose(); this.countdownPart = null; }
        if (this.part) { this.part.stop(0); this.part.dispose(); this.part = null; }
        if(this.bassSynth) { this.bassSynth.triggerRelease(); this.chordSynth.releaseAll(); }
        Tone.Transport.stop();
        Tone.Transport.cancel(0);
        Tone.Transport.position = 0;
        Tone.Transport.loop = false;
        Tone.Transport.loopStart = 0;
        this.setPlaybackState(PlaybackState.Stopped);
        this.setActiveGridIndex(-1);
    }
}

// ====================================================================================
// START: components/Icons.js
// ====================================================================================

const FullscreenEnterIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 8V4m0 0h4M4 4l5 5m11-5h-4m0 0v4m0-4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5h-4m0 0v-4m0 4l-5-5" />
    </svg>
);
const FullscreenExitIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 4h5v5M9 4H4v5M15 20h5v-5M9 20H4v-5" />
    </svg>
);
const PlayIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
);
const StopIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
);
const MetronomeIcon = () => (
    <svg title="M√©tronome" xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
        <path strokeLinecap="round" strokeLinejoin="round" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
    </svg>
);
const BassIcon = () => (
    <svg title="Basse" xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2z" />
    </svg>
);
const ChordIcon = () => (
    <svg title="Nappes" xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 17v-2m3 2v-4m3 4v-6m3 6V7m-9 4h9" />
    </svg>
);

// ====================================================================================
// START: components/* (Header, etc.)
// ====================================================================================

const Header = () => {
    const [isFullscreen, setIsFullscreen] = React.useState(false);
    const toggleFullScreen = () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.warn(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        } else {
            if (document.exitFullscreen) document.exitFullscreen();
        }
    };
    React.useEffect(() => {
        const onFullscreenChange = () => setIsFullscreen(!!document.fullscreenElement);
        document.addEventListener('fullscreenchange', onFullscreenChange);
        return () => document.removeEventListener('fullscreenchange', onFullscreenChange);
    }, []);
    return (
        <React.Fragment>
            <div className="absolute top-2 right-2 z-20">
                <button onClick={toggleFullScreen} title="Plein √©cran" className="p-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition">
                    {isFullscreen ? <FullscreenExitIcon /> : <FullscreenEnterIcon />}
                </button>
            </div>
            <header className="text-center mb-6">
                <h1 className="text-3xl md:text-4xl font-extrabold text-white mb-1">üé∏ GIA Navigator</h1>
                <p className="text-md text-gray-400">Votre plan d'action visuel pour l'improvisation.</p>
            </header>
        </React.Fragment>
    );
};

const InputGrid = ({ chords, onChordChange, onClear, onRandom, activeGridIndex }) => (
    <React.Fragment>
        <div className="flex justify-between items-center mb-2">
            <h2 className="text-lg font-bold text-white">1. Entrez votre grille (1 case = 2 temps)</h2>
            <div className="flex gap-2">
                <button onClick={onRandom} title="G√©n√©rer une grille al√©atoire" className="text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 font-semibold py-1 px-3 rounded-lg transition">üé≤ Al√©atoire</button>
                <button onClick={onClear} title="Vider la grille" className="text-xs bg-red-800/50 hover:bg-red-700 text-white font-semibold py-1 px-3 rounded-lg transition">üóëÔ∏è Vider</button>
            </div>
        </div>
        <div className="grid grid-cols-8 gap-1 mb-3">
            {Array.from({ length: TOTAL_CELLS }).map((_, i) => (
                <input key={i} type="text" value={chords[i]} onChange={(e) => onChordChange(i, e.target.value)} className={`input-grid-cell bg-gray-900 border border-gray-600 rounded-lg w-full p-1 text-center text-sm font-bold text-white transition focus:outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-500/50 ${activeGridIndex === i ? 'cell-active' : ''}`} aria-label={`Accord ${i + 1}`} />
            ))}
        </div>
    </React.Fragment>
);

const NoteDot = ({ cx, cy, noteItem, noteSelection, isPreview, isPlaybackActive }) => {
    const colors = { fondatrice: '#10B981', expressive: '#8B5CF6', preview: '#FBBF24' };
    if (noteSelection) {
        return (
            <g>
                <circle cx={cx} cy={cy} r={9} fill={noteSelection.color} className="note-dot" />
                <text x={cx} y={cy} className="note-dot-text">{noteSelection.chordNumber}</text>
                <text x={cx} y={cy + 15} className="note-name-text">{noteSelection.noteItem.note}</text>
            </g>
        );
    }
    if (noteItem) {
        const fill = isPreview ? colors.preview : (colors[noteItem.type] || '#FFFFFF');
        const className = `note-dot ${!isPreview && isPlaybackActive ? 'note-dot-active' : ''}`;
        return <circle cx={cx} cy={cy} r={9} fill={fill} stroke="#111827" className={className} />;
    }
    return null;
};
const GuitarNeck = ({ pentatonicNotes, displayNotes, notePositions, currentZone }) => {
    const svgRef = React.useRef(null);
    const [width, setWidth] = React.useState(0);
    React.useEffect(() => {
        const resizeObserver = new ResizeObserver(entries => {
            if (entries[0]) setWidth(entries[0].contentRect.width);
        });
        if (svgRef.current) resizeObserver.observe(svgRef.current);
        return () => resizeObserver.disconnect();
    }, []);
    if (width === 0) {
        return <div className="w-full overflow-x-auto pb-2.5"><svg ref={svgRef} className="w-full h-[170px]"></svg></div>;
    }
    const NECK_WIDTH = width - 50;
    const isPlaybackActive = !!(displayNotes.active || displayNotes.preview);
    const getPosition = (fret) => 50 + ((fret - 0.5) * (NECK_WIDTH / 17));
    const getStringY = (stringIndex) => (140 / 12) * (stringIndex * 2 + 1);
    const fretMarkers = { 3:1, 5:1, 7:1, 9:1, 12:2, 15:1, 17:1 };

    // Function to check if a fret is within the currently selected zone
    const isVisible = (fret) => fret >= currentZone.min && fret <= currentZone.max;

    return (
        <div className="w-full overflow-x-auto pb-2.5">
            <svg ref={svgRef} className="w-full h-[170px]">
                <defs><linearGradient id="woodGrain" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style={{stopColor: '#6b4629', stopOpacity: 1}} /><stop offset="100%" style={{stopColor: '#4a2f19', stopOpacity: 1}} /></linearGradient></defs>
                <rect x={0} y={0} width={width} height={140} fill="url(#woodGrain)" />
                {/* Filter Background Dots based on Zone */}
                <g>{pentatonicNotes.flatMap(note => notePositions.get(note).filter(([, fret]) => fret > 0 && fret <= 17 && isVisible(fret)).map(([string, fret], i) => <circle key={`${note}-${string}-${fret}-${i}`} cx={getPosition(fret)} cy={getStringY(string)} r={10} fill="none" stroke="#6B7280" strokeWidth="2" opacity="0.6" />))}</g>
                
                {Array.from({ length: 18 }).map((_, i) => <line key={`fret-${i}`} x1={50 + (i * (NECK_WIDTH / 17))} y1={getStringY(0)} x2={50 + (i * (NECK_WIDTH / 17))} y2={getStringY(5)} stroke={i === 0 ? '#e5e7eb' : '#a0a0a0'} strokeWidth={i === 0 ? 6 : 3} />)}
                {Array.from({ length: 6 }).map((_, i) => <line key={`string-${i}`} x1={50} y1={getStringY(i)} x2={width} y2={getStringY(i)} stroke="#cbd5e1" strokeWidth={1 + (i * 0.2)} />)}
                
                {Object.entries(fretMarkers).map(([fret, num]) => {
                    const x = getPosition(parseInt(fret));
                    if (num === 1) return <circle key={`marker-${fret}`} cx={x} cy={70} r={5} fill="#e5e7eb" opacity="0.2" />;
                    return <g key={`marker-${fret}`}><circle cx={x} cy={35} r={5} fill="#e5e7eb" opacity="0.2" /><circle cx={x} cy={105} r={5} fill="#e5e7eb" opacity="0.2" /></g>;
                })}
                {[3, 5, 7, 9, 12, 15, 17].map(fret => <text key={`fret-label-${fret}`} x={getPosition(fret)} y={155} className="fret-number-text">{fret}</text>)}
                <g>
                    {/* Filter Active/Preview Dots based on Zone */}
                    {displayNotes.multi ? (
                        displayNotes.multi.flatMap(sel => notePositions.get(sel.noteItem.note).filter(([, fret]) => fret > 0 && fret <= 17 && isVisible(fret)).map(([string, fret], i) => <NoteDot key={`note-multi-${sel.chordNumber}-${string}-${fret}-${i}`} cx={getPosition(fret)} cy={getStringY(string)} noteSelection={sel} isPlaybackActive={false} />))
                    ) : (
                        <React.Fragment>
                            {(displayNotes.preview || []).flatMap(item => notePositions.get(item.note).filter(([, fret]) => fret > 0 && fret <= 17 && isVisible(fret)).map(([string, fret], i) => <NoteDot key={`note-preview-${item.note}-${string}-${fret}-${i}`} cx={getPosition(fret)} cy={getStringY(string)} noteItem={item} isPreview={true} isPlaybackActive={isPlaybackActive} />))}
                            {(displayNotes.active || []).flatMap(item => notePositions.get(item.note).filter(([, fret]) => fret > 0 && fret <= 17 && isVisible(fret)).map(([string, fret], i) => <NoteDot key={`note-active-${item.note}-${string}-${fret}-${i}`} cx={getPosition(fret)} cy={getStringY(string)} noteItem={item} isPlaybackActive={isPlaybackActive} />))}
                        </React.Fragment>
                    )}
                </g>
            </svg>
        </div>
    );
};

const PlayerControls = ({ playbackState, onPlayStop, tempo, onTempoChange, volumes, onVolumeChange }) => {
    const getButtonText = () => {
        switch(playbackState) {
            case PlaybackState.Playing: return 'Stop';
            case PlaybackState.Countdown: return '...';
            case PlaybackState.Stopped: return 'Play';
            default: return 'Play';
        }
    };
    return (
        <div className="mt-3 flex flex-col gap-4 p-3 bg-gray-900/50 rounded-lg">
            <div className="flex flex-col sm:flex-row items-center justify-center gap-4">
                <button id="play-stop-btn" onClick={onPlayStop} disabled={playbackState === PlaybackState.Countdown} className="w-full sm:w-auto bg-emerald-600 hover:bg-emerald-700 disabled:bg-emerald-800 disabled:cursor-not-allowed text-white font-bold py-2 px-6 rounded-lg transition duration-300 flex items-center justify-center gap-2">
                    {playbackState !== PlaybackState.Playing ? <PlayIcon /> : <StopIcon />} <span className="w-16 text-left">{getButtonText()}</span>
                </button>
                <div className="flex items-center gap-2 w-full sm:w-auto">
                    <label htmlFor="tempo-slider" className="font-semibold text-gray-300">Tempo:</label>
                    <input type="range" id="tempo-slider" min="45" max="180" value={tempo} onChange={(e) => onTempoChange(Number(e.target.value))} className="w-full" />
                    <span className="font-bold text-white w-12 text-center">{tempo} bpm</span>
                </div>
            </div>
            <div className="grid grid-cols-3 gap-x-6 gap-y-2 items-center pt-2 border-t border-gray-700/50">
                <div className="flex items-center gap-2 w-full"><MetronomeIcon /><input type="range" title="M√©tronome" min="-48" max="0" value={volumes.metro} onChange={(e) => onVolumeChange('metro', Number(e.target.value))} className="w-full" /></div>
                <div className="flex items-center gap-2 w-full"><BassIcon /><input type="range" title="Basse" min="-48" max="0" value={volumes.bass} onChange={(e) => onVolumeChange('bass', Number(e.target.value))} className="w-full" /></div>
                <div className="flex items-center gap-2 w-full"><ChordIcon /><input type="range" title="Nappes" min="-48" max="0" value={volumes.chord} onChange={(e) => onVolumeChange('chord', Number(e.target.value))} className="w-full" /></div>
            </div>
        </div>
    );
};

const AnalysisCard = ({ analysis, setModalContent, onTargetNoteChange, isSelected, onSelectToggle, selectionColor, isPlaybackActive }) => {
    // Only handle badge click for the visible badge (OUT_OF_KEY)
    const handleBadgeClick = (e) => {
        e.stopPropagation();
        if (analysis.front === 'OUT_OF_KEY') {
             setModalContent({
                title: 'Front de la Tension (Hors Tonalit√©)',
                body: "Cet accord contient des notes √©trang√®res √† la gamme, cr√©ant un 'choc' harmonique. Il g√©n√®re une tension qui demande √† √™tre g√©r√©e."
            });
        }
    };

    const cardClasses = { 'TENSION': 'border-rose-700', 'OUT_OF_KEY': 'border-amber-500', 'R√âSOLUTION': 'border-blue-700' };
    
    // Only specific badge
    const showBadge = analysis.front === 'OUT_OF_KEY';
    
    return (
        <div className={`p-1 w-1/2 md:w-1/3 lg:w-1/4 transition-transform duration-200 ${isSelected ? 'transform scale-[1.02]' : ''}`}>
            <div className={`relative bg-gray-800 border-2 rounded-lg p-2 flex flex-col h-full space-y-2 transition-all duration-200 ${cardClasses[analysis.front]} ${isSelected ? 'shadow-lg shadow-violet-500/30' : ''}`}>
                 <div onClick={() => onSelectToggle(analysis.analysisIndex)} className={`absolute top-2 left-2 w-4 h-4 rounded-full border-2 transition-all duration-200 ${isPlaybackActive ? 'cursor-not-allowed bg-gray-700 border-gray-600' : 'cursor-pointer'}`} style={{ borderColor: isSelected ? selectionColor : '#6b7280', backgroundColor: isSelected ? selectionColor : 'transparent' }}></div>
                <div className="flex-shrink-0">
                    <div className="flex justify-between items-start mb-1">
                        <h3 className="text-lg font-extrabold text-white pl-6">{analysis.accord} <span className="text-base font-semibold text-gray-400">{analysis.degre}</span></h3>
                        {showBadge && (
                             <span onClick={handleBadgeClick} className="inline-block px-2.5 py-0.5 rounded-full font-semibold text-xs text-center cursor-pointer transition transform hover:scale-105 bg-amber-600 text-amber-100">HORS TONALIT√â</span>
                        )}
                    </div>
                </div>
                <div className="flex-grow space-y-2">
                    <div>
                        <p className="text-[11px] text-violet-400 font-bold tracking-wider mb-1">NOTES DE L'ACCORD</p>
                        <div className="space-y-1">
                            {analysis.allTargetOptions.map((item, index) => {
                                const id = `target-${analysis.analysisIndex}-${index}`;
                                const isChecked = analysis.selectedNote?.note === item.note && analysis.selectedNote?.interval === item.interval;
                                return (
                                    <div key={id}>
                                        <input type="radio" name={`target-choice-${analysis.analysisIndex}`} id={id} value={index} className="hidden" checked={isChecked} onChange={() => onTargetNoteChange(analysis.analysisIndex, index)} />
                                        <label htmlFor={id} className={`block cursor-pointer p-2 rounded-md border transition-all ${isChecked ? 'bg-violet-800 border-violet-400 text-white' : 'bg-gray-500/20 border-gray-600 hover:bg-gray-500/40 hover:border-gray-500'}`}>
                                            <span className="font-bold text-sm">{item.note} ({item.interval})</span> - <span className="text-gray-400 text-xs">{item.intention}</span>
                                        </label>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};

const AnalysisSection = ({ keySignature, scaleNotes, analysisResults, setModalContent, onTargetNoteChange, onCardSelectionChange, isPlaybackActive, scaleMode, setScaleMode }) => {
    const [selectedCardIndices, setSelectedCardIndices] = React.useState(new Set());
    const multiSelectColors = ['#FBBF24', '#34D399', '#F87171', '#60A5FA', '#EC4899', '#8B5CF6'];
    const handleExport = () => {
        if (analysisResults.length === 0) return;
        const headers = ['Accord', 'Degr√©', 'Front GIA', 'Action Rythmique', 'Note Cible Choisie', 'Intention Choisie', 'Intervalle Cible'];
        const rows = analysisResults.map(res => {
            if (!res.accord) return null;
            const selected = res.selectedNote;
            return [`"${res.accord}"`, `"${res.degre}"`, `"${res.front}"`, `"${res.actionRythmique}"`, selected ? `"${selected.note}"` : '""', selected ? `"${selected.intention}"` : '""', selected ? `"${selected.interval}"` : '""'];
        }).filter(row => row !== null);
        const csvContent = "data:text/csv;charset=utf-8," + headers.join(",") + "\n" + rows.map(e => e.join(",")).join("\n");
        const link = document.createElement("a");
        link.setAttribute("href", encodeURI(csvContent));
        link.setAttribute("download", "analyse_gia_navigator.csv");
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    };
    const handleCardSelectToggle = (analysisIndex) => {
        if (isPlaybackActive) return;
        const newSet = new Set(selectedCardIndices);
        if (newSet.has(analysisIndex)) { newSet.delete(analysisIndex); } else { newSet.add(analysisIndex); }
        setSelectedCardIndices(newSet);
    };
    React.useEffect(() => { if (isPlaybackActive) setSelectedCardIndices(new Set()); }, [isPlaybackActive]);
    React.useEffect(() => {
        const selections = [];
        const selectedArray = Array.from(selectedCardIndices);
        selectedArray.forEach((analysisIndex, i) => {
            const analysis = analysisResults.find(r => r.analysisIndex === analysisIndex);
            if (analysis && analysis.selectedNote) {
                selections.push({
                    noteItem: analysis.selectedNote,
                    chordNumber: analysis.analysisIndex + 1,
                    color: multiSelectColors[i % multiSelectColors.length],
                });
            }
        });
        onCardSelectionChange(selections);
    }, [selectedCardIndices, analysisResults, onCardSelectionChange]);
    
    return (
        <div className="p-3 bg-gray-800/50 rounded-xl border border-gray-700">
            <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-4 gap-4">
                <div className="flex-1">
                    <h2 className="text-lg font-bold text-gray-400 uppercase tracking-wider mb-2">2. Votre Plan d'Action GIA</h2>
                    {keySignature ? (
                        <div className="flex flex-wrap items-center gap-4">
                            <div className="bg-blue-900/40 border border-blue-500/30 px-4 py-2 rounded-lg">
                                <span className="text-blue-200 text-sm font-semibold uppercase block">Tonalit√© d√©tect√©e</span>
                                <span className="text-2xl font-bold text-white">{keySignature.name}</span>
                            </div>
                            
                            <div className="flex flex-col gap-1">
                                <span className="text-gray-400 text-xs font-semibold uppercase">Gamme √† visualiser</span>
                                <div className="flex bg-gray-700 p-1 rounded-lg">
                                    <button 
                                        onClick={() => setScaleMode('pentatonic')}
                                        className={`px-3 py-1 text-sm font-bold rounded-md transition-all ${scaleMode === 'pentatonic' ? 'bg-blue-600 text-white shadow' : 'text-gray-400 hover:text-gray-200'}`}
                                    >
                                        Penta
                                    </button>
                                    <button 
                                        onClick={() => setScaleMode('full')}
                                        className={`px-3 py-1 text-sm font-bold rounded-md transition-all ${scaleMode === 'full' ? 'bg-blue-600 text-white shadow' : 'text-gray-400 hover:text-gray-200'}`}
                                    >
                                        7 Sons
                                    </button>
                                </div>
                            </div>
                        </div>
                    ) : (
                         <p className="text-gray-500 italic">Entrez des accords pour d√©tecter la tonalit√©...</p>
                    )}
                </div>

                {analysisResults.length > 0 && (
                     <button onClick={handleExport} className="bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center gap-2 text-sm">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                        Exporter
                    </button>
                )}
            </div>

            {keySignature && (
                 <div className="mb-4 flex flex-wrap gap-2">
                    {scaleNotes.map((note, idx) => (
                        <div key={note} className={`w-8 h-8 flex items-center justify-center rounded-full text-sm font-bold border ${note === keySignature.root ? 'bg-blue-600 border-blue-400 text-white' : 'bg-gray-700 border-gray-600 text-gray-300'}`}>
                            {note}
                        </div>
                    ))}
                 </div>
            )}
            
            <div className="flex flex-wrap -m-1">
                {analysisResults.map((result) => <AnalysisCard key={result.gridIndex} analysis={result} setModalContent={setModalContent} onTargetNoteChange={onTargetNoteChange} isSelected={selectedCardIndices.has(result.analysisIndex)} onSelectToggle={handleCardSelectToggle} selectionColor={multiSelectColors[Array.from(selectedCardIndices).indexOf(result.analysisIndex) % multiSelectColors.length]} isPlaybackActive={isPlaybackActive} />)}
            </div>
        </div>
    );
};

const InfoModal = ({ modalContent, setModalContent }) => {
    React.useEffect(() => {
        const handleEsc = (event) => { if (event.key === 'Escape') setModalContent(null); };
        window.addEventListener('keydown', handleEsc);
        return () => window.removeEventListener('keydown', handleEsc);
    }, [setModalContent]);
    if (!modalContent) return null;
    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 transition-opacity duration-300 ease-in-out">
            <div className="absolute inset-0" onClick={() => setModalContent(null)}></div>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md z-10 transform transition-all duration-300 ease-in-out scale-100 opacity-100">
                <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-bold text-white">{modalContent.title}</h3>
                    <button onClick={() => setModalContent(null)} className="text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
                </div>
                <p className="text-gray-300">{modalContent.body}</p>
            </div>
        </div>
    );
};


// ====================================================================================
// START: App.js (Main Component)
// ====================================================================================

const App = () => {
    const [chords, setChords] = React.useState(Array(TOTAL_CELLS).fill(''));
    const [analysisResults, setAnalysisResults] = React.useState([]);
    const [key, setKey] = React.useState(null);
    const [scaleNotes, setScaleNotes] = React.useState([]);
    const [pentatonicNotes, setPentatonicNotes] = React.useState([]);
    const [playbackState, setPlaybackState] = React.useState(PlaybackState.Stopped);
    const [tempo, setTempo] = React.useState(45);
    const [volumes, setVolumes] = React.useState({ metro: -12, bass: -6, chord: -14 });
    const [modalContent, setModalContent] = React.useState(null);
    const [activeGridIndex, setActiveGridIndex] = React.useState(-1);
    const [neckNotes, setNeckNotes] = React.useState({});
    const [notePositions] = React.useState(() => new NotePositions());
    const [scaleMode, setScaleMode] = React.useState('pentatonic'); // 'pentatonic' or 'full'
    const [currentZone, setCurrentZone] = React.useState(ZONES[0]); // Default to 'Tout le manche'
    
    const toneService = React.useRef(null);
    
    const updateAnalysis = React.useCallback(() => {
        const { key: newKey, results } = analyzeProgression(chords, notePositions);
        setKey(newKey);
        setAnalysisResults(results);
        if (newKey) {
            setScaleNotes(getScaleNotes(newKey));
            setPentatonicNotes(getPentatonicScaleNotes(newKey, notePositions));
        } else {
            setScaleNotes([]);
            setPentatonicNotes([]);
        }
    }, [chords, notePositions]);

    React.useEffect(() => { updateAnalysis(); }, [chords, updateAnalysis]);

    React.useEffect(() => {
        if (playbackState === PlaybackState.Stopped) {
            const firstSelectedNote = analysisResults.find(r => r.selectedNote)?.selectedNote;
            setNeckNotes(firstSelectedNote ? { active: [firstSelectedNote] } : {});
        }
    }, [playbackState, analysisResults]);
    
    const updateNeckForPlayback = React.useCallback((gridIndex) => {
        let currentAnalysis = null;
        for (let i = gridIndex; i >= 0; i--) {
            const analysis = analysisResults.find(a => a.gridIndex === i);
            if (analysis) { currentAnalysis = analysis; break; }
        }
        if (!currentAnalysis) { setNeckNotes({}); return; }
        const nextAnalysis = analysisResults.find(a => a.analysisIndex === currentAnalysis.analysisIndex + 1) || analysisResults[0];
        setNeckNotes({
            active: currentAnalysis.selectedNote ? [currentAnalysis.selectedNote] : [],
            preview: nextAnalysis?.selectedNote ? [nextAnalysis.selectedNote] : []
        });
    }, [analysisResults]);

    const handlePlayStop = React.useCallback(async () => {
        if (!toneService.current) {
            await Tone.start();
            const newToneService = new ToneService(setActiveGridIndex, setPlaybackState, (index) => updateNeckForPlayback(index));
            await newToneService.init();
            toneService.current = newToneService;
            toneService.current.setTempo(tempo);
            Object.entries(volumes).forEach(([instrument, volume]) => toneService.current?.setVolume(instrument, volume));
        }
        if (playbackState !== PlaybackState.Stopped) {
            toneService.current?.stop();
        } else {
            const firstChord = chords.find(c => c.trim() !== '');
            if (firstChord) {
                toneService.current?.play(chords, analysisResults, notePositions);
            }
        }
    }, [playbackState, chords, analysisResults, notePositions, updateNeckForPlayback, tempo, volumes]);

    const handleTempoChange = React.useCallback((newTempo) => {
        setTempo(newTempo);
        toneService.current?.setTempo(newTempo);
    }, []);

    const handleVolumeChange = React.useCallback((instrument, volume) => {
        setVolumes(prev => ({ ...prev, [instrument]: volume }));
        toneService.current?.setVolume(instrument, volume);
    }, []);
    
    const handleChordChange = React.useCallback((index, value) => {
        const newChords = [...chords];
        newChords[index] = value;
        setChords(newChords);
    }, [chords]);

    const handleClearGrid = React.useCallback(() => { setChords(Array(TOTAL_CELLS).fill('')); }, []);

    const handleRandomGrid = React.useCallback(() => {
        const randomProg = PRESET_PROGRESSIONS[Math.floor(Math.random() * PRESET_PROGRESSIONS.length)];
        const newChords = Array(TOTAL_CELLS).fill('');
        randomProg.chords.forEach((chord, i) => { if (i < newChords.length) newChords[i] = chord; });
        setChords(newChords);
    }, []);
    
    const handleTargetNoteChange = React.useCallback((analysisIndex, optionIndex) => {
        const newResults = analysisResults.map(res => (res.analysisIndex === analysisIndex) ? { ...res, selectedNote: res.allTargetOptions[optionIndex] } : res);
        setAnalysisResults(newResults);
    }, [analysisResults]);

    const handleCardSelectionChange = (newSelections) => {
        if (newSelections.length > 0) {
            setNeckNotes({ multi: newSelections });
        } else if (playbackState === PlaybackState.Stopped) {
            const firstSelectedNote = analysisResults.find(r => r.selectedNote)?.selectedNote;
            setNeckNotes(firstSelectedNote ? { active: [firstSelectedNote] } : {});
        }
    };
    
    const backgroundNotes = scaleMode === 'pentatonic' ? pentatonicNotes : scaleNotes;

    return (
        <div className="min-h-screen flex flex-col items-center">
            <div className="w-full max-w-7xl mx-auto relative">
                <Header />
                <div className="mb-2 p-3 bg-gray-800/50 rounded-xl border border-gray-700">
                    <InputGrid chords={chords} onChordChange={handleChordChange} onClear={handleClearGrid} onRandom={handleRandomGrid} activeGridIndex={activeGridIndex} />
                    
                    <div className="flex justify-between items-end mb-2">
                        <h3 className="text-sm font-bold text-gray-400 uppercase tracking-wider">Visualisation</h3>
                        <div className="flex bg-gray-700 p-1 rounded-lg">
                            {ZONES.map((z, i) => (
                                <button
                                    key={i}
                                    onClick={() => setCurrentZone(z)}
                                    className={`px-2 py-1 text-xs font-bold rounded-md transition-all ${currentZone.label === z.label ? 'bg-blue-600 text-white shadow' : 'text-gray-400 hover:text-gray-200'}`}
                                >
                                    {z.label}
                                </button>
                            ))}
                        </div>
                    </div>
                    
                    <GuitarNeck 
                        pentatonicNotes={backgroundNotes} 
                        displayNotes={neckNotes} 
                        notePositions={notePositions} 
                        currentZone={currentZone}
                    />
                    
                    <PlayerControls playbackState={playbackState} onPlayStop={handlePlayStop} tempo={tempo} onTempoChange={handleTempoChange} volumes={volumes} onVolumeChange={handleVolumeChange} />
                </div>
                <AnalysisSection 
                    keySignature={key} 
                    scaleNotes={scaleNotes} 
                    analysisResults={analysisResults} 
                    setModalContent={setModalContent} 
                    onTargetNoteChange={handleTargetNoteChange} 
                    onCardSelectionChange={handleCardSelectionChange} 
                    isPlaybackActive={playbackState !== PlaybackState.Stopped} 
                    scaleMode={scaleMode}
                    setScaleMode={setScaleMode}
                />
                <footer className="text-center mt-4 text-gray-500 text-sm"><p>D√©velopp√© pour la Guitare Impro Acad√©mie par Fran√ßois.</p></footer>
            </div>
            <InfoModal modalContent={modalContent} setModalContent={setModalContent} />
        </div>
    );
};

// ====================================================================================
// START: Render App
// ====================================================================================

const rootElement = document.getElementById('root');
const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

    </script>
</body>
</html>